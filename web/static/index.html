<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flow Control Simulator - Visualization</title>
    <script src="https://cdn.jsdelivr.net/npm/cytoscape@3.27.0/dist/cytoscape.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        .control-panel {
            width: 350px;
            background: #f5f5f5;
            border-right: 1px solid #ddd;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        .control-section {
            padding: 15px;
            border-bottom: 1px solid #ddd;
        }

        .control-section h3 {
            margin-bottom: 10px;
            color: #333;
            font-size: 14px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .control-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        button {
            padding: 8px 16px;
            border: 1px solid #ccc;
            background: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }

        button:hover:not(:disabled) {
            background: #f0f0f0;
            border-color: #999;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        button.primary {
            background: #007bff;
            color: white;
            border-color: #007bff;
        }

        button.primary:hover:not(:disabled) {
            background: #0056b3;
        }

        button.danger {
            background: #dc3545;
            color: white;
            border-color: #dc3545;
        }

        button.danger:hover:not(:disabled) {
            background: #c82333;
        }

        .status-info {
            font-size: 12px;
            color: #666;
            margin-top: 8px;
        }

        .status-info strong {
            color: #333;
        }

        .config-form {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .form-group label {
            font-size: 12px;
            color: #666;
            font-weight: 500;
        }

        .form-group input {
            padding: 6px 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 13px;
        }

        .form-group input:focus {
            outline: none;
            border-color: #007bff;
        }

        .form-row {
            display: flex;
            gap: 10px;
        }

        .form-row .form-group {
            flex: 1;
        }

        .stats-panel {
            max-height: 400px;
            overflow-y: auto;
        }

        .stats-item {
            padding: 8px;
            background: white;
            border-radius: 4px;
            margin-bottom: 8px;
            font-size: 12px;
        }

        .stats-item h4 {
            margin-bottom: 6px;
            color: #333;
            font-size: 13px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            margin-top: 6px;
        }

        .stats-value {
            color: #666;
        }

        .stats-value strong {
            color: #333;
        }

        .visualization-area {
            flex: 1;
            position: relative;
            background: #fff;
        }

        #cy {
            width: 100%;
            height: 100%;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 20px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            z-index: 1000;
        }

        .error-message {
            padding: 10px;
            background: #fee;
            border: 1px solid #fcc;
            border-radius: 4px;
            color: #c33;
            font-size: 12px;
            margin-top: 10px;
            display: none;
        }

        .error-message.show {
            display: block;
        }

        .queue-info {
            font-size: 11px;
            color: #666;
            margin-top: 4px;
        }

        /* Modal styles */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 10000;
            justify-content: center;
            align-items: center;
        }

        .modal-overlay.show {
            display: flex;
        }

        .modal-content {
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            max-width: 800px;
            max-height: 90vh;
            width: 90%;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .modal-header {
            padding: 20px;
            border-bottom: 1px solid #ddd;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #f5f5f5;
        }

        .modal-header h2 {
            margin: 0;
            font-size: 18px;
            color: #333;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #666;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
        }

        .modal-close:hover {
            background: #e0e0e0;
            color: #333;
        }

        .modal-body {
            padding: 20px;
            overflow-y: auto;
            flex: 1;
        }

        .queue-section {
            margin-bottom: 30px;
        }

        .queue-section h3 {
            font-size: 16px;
            color: #333;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 2px solid #007bff;
        }

        .queue-section.empty {
            color: #999;
            font-style: italic;
            padding: 20px;
            text-align: center;
        }

        .packet-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
            font-size: 13px;
        }

        .packet-table th {
            background: #f5f5f5;
            padding: 10px;
            text-align: left;
            border-bottom: 2px solid #ddd;
            font-weight: 600;
            color: #333;
        }

        .packet-table td {
            padding: 10px;
            border-bottom: 1px solid #eee;
        }

        .packet-table tr:hover {
            background: #f9f9f9;
        }

        .packet-id {
            font-weight: 600;
            color: #007bff;
        }

        .packet-field-label {
            font-weight: 500;
            color: #666;
            width: 150px;
        }

        .packet-field-value {
            color: #333;
        }

        .packet-item {
            margin-bottom: 20px;
            border: 1px solid #ddd;
            border-radius: 4px;
            overflow: hidden;
        }

        .packet-item-header {
            background: #f5f5f5;
            padding: 10px 15px;
            font-weight: 600;
            color: #333;
            border-bottom: 1px solid #ddd;
        }

        .packet-item-body {
            padding: 15px;
        }

        @media (max-width: 768px) {
            body {
                flex-direction: column;
            }

            .control-panel {
                width: 100%;
                max-height: 40vh;
            }
        }
    </style>
</head>
<body>
    <div class="control-panel">
        <div class="control-section">
            <h3>Simulation Control</h3>
            <div class="control-buttons">
                <button id="btnPause" class="primary">Pause</button>
                <button id="btnResume" class="primary">Resume</button>
                <button id="btnStep" class="primary">Step</button>
                <button id="btnReset" class="danger">Reset</button>
            </div>
            <div class="status-info">
                <div>Cycle: <strong id="currentCycle">-</strong></div>
                <div>In-Flight: <strong id="inFlightCount">-</strong></div>
                <div id="simStatus">Status: <strong>Waiting</strong></div>
            </div>
            <div id="errorMessage" class="error-message"></div>
        </div>

        <div class="control-section">
            <h3>Configuration</h3>
            <div class="config-form">
                <div class="form-group">
                    <label>Network Configuration</label>
                    <select id="networkConfig" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                        <option value="">Loading configurations...</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Total Cycles</label>
                    <input type="number" id="totalCycles" min="1" value="1000">
                </div>
            </div>
            <div class="status-info" style="margin-top: 10px; font-size: 11px; color: #999;">
                Select a predefined network configuration. Changes take effect after Reset.
            </div>
        </div>

        <div class="control-section">
            <h3>Statistics</h3>
            <div class="stats-panel" id="statsPanel">
                <div class="stats-item">
                    <div style="text-align: center; color: #999;">No data available</div>
                </div>
            </div>
        </div>
    </div>

    <div class="visualization-area">
        <div id="cy"></div>
        <svg id="pipelineOverlay" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10;"></svg>
        <div id="loading" class="loading" style="display: none;">
            <div>Loading simulation data...</div>
        </div>
    </div>

    <!-- Modal for displaying packet information -->
    <div id="packetModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modalTitle">Node Packet Information</h2>
                <button class="modal-close" id="modalClose">&times;</button>
            </div>
            <div class="modal-body" id="modalBody">
                <!-- Content will be populated by JavaScript -->
            </div>
        </div>
    </div>

    <script>
        let cy;
        let pollInterval;
        let isPaused = true; // Web mode starts paused at cycle 0
        let currentFrame = null;
        let topologyInitialized = false;

        // Calculate load percentage for a queue
        function calculateQueueLoad(queue) {
            if (!queue || queue.capacity === -1 || queue.capacity === 0) {
                return 0; // Unlimited capacity or invalid capacity
            }
            const load = Math.min(100, Math.max(0, (queue.length / queue.capacity) * 100));
            return load;
        }

        // Get color for load percentage
        function getLoadColor(percentage) {
            if (percentage < 50) {
                return '#52c41a'; // Green for low load
            } else if (percentage < 80) {
                return '#faad14'; // Yellow for medium load
            } else {
                return '#ff4d4f'; // Red for high load
            }
        }

        // Create progress bar SVG for multiple queues
        function createProgressBarsSVG(queues, nodeWidth, nodeHeight) {
            if (!queues || queues.length === 0) {
                return 'none';
            }

            const progressBarHeight = 3;
            const progressBarSpacing = 1;
            const totalProgressHeight = queues.length * progressBarHeight + (queues.length - 1) * progressBarSpacing;
            const padding = 2;
            const startY = nodeHeight - totalProgressHeight - padding;

            let svgParts = [];
            
            // Draw transparent background for the entire node (so the original background color shows through)
            svgParts.push(`<rect x="0" y="0" width="${nodeWidth}" height="${nodeHeight}" fill="transparent"/>`);
            
            queues.forEach((queue, index) => {
                const load = calculateQueueLoad(queue);
                const y = startY + index * (progressBarHeight + progressBarSpacing);
                const progressWidth = (load / 100) * nodeWidth;
                const color = getLoadColor(load);

                // Background bar (gray, semi-transparent)
                svgParts.push(`<rect x="0" y="${y}" width="${nodeWidth}" height="${progressBarHeight}" fill="#e0e0e0" opacity="0.6" rx="1"/>`);
                
                // Progress bar (colored)
                if (progressWidth > 0) {
                    svgParts.push(`<rect x="0" y="${y}" width="${progressWidth}" height="${progressBarHeight}" fill="${color}" rx="1"/>`);
                }
            });

            const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${nodeWidth}" height="${nodeHeight}">${svgParts.join('')}</svg>`;
            return 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svg);
        }

        // Custom layout: Master on left, Slave on right, Relay in center
        function applyCustomLayout() {
            if (!cy || cy.elements().length === 0) {
                return;
            }
            
            const containerWidth = cy.width();
            const containerHeight = cy.height();
            
            // Use default dimensions if container not ready
            if (containerWidth === 0 || containerHeight === 0) {
                return;
            }
            
            const leftX = containerWidth * 0.2;      // Master nodes on left
            const centerX = containerWidth * 0.5;   // Relay in center
            const rightX = containerWidth * 0.8;     // Slave nodes on right
            
            // Support both CHI node types (RN/HN/SN) and legacy types (master/slave/relay)
            const masters = cy.nodes('[type="RN"], [type="master"]');
            const slaves = cy.nodes('[type="SN"], [type="slave"]');
            const relays = cy.nodes('[type="HN"], [type="relay"]');
            
            // Layout Master nodes on left, vertically distributed
            if (masters.length > 0) {
                const masterSpacing = Math.min(containerHeight / Math.max(masters.length + 1, 2), 150);
                const totalHeight = (masters.length - 1) * masterSpacing;
                const startY = (containerHeight - totalHeight) / 2;
                masters.forEach((node, index) => {
                    node.position({
                        x: leftX,
                        y: startY + index * masterSpacing
                    });
                });
            }
            
            // Layout Relay node(s) in center
            if (relays.length > 0) {
                relays.forEach((node) => {
                    node.position({
                        x: centerX,
                        y: containerHeight / 2
                    });
                });
            }
            
            // Layout Slave nodes on right, vertically distributed
            if (slaves.length > 0) {
                const slaveSpacing = Math.min(containerHeight / Math.max(slaves.length + 1, 2), 150);
                const totalHeight = (slaves.length - 1) * slaveSpacing;
                const startY = (containerHeight - totalHeight) / 2;
                slaves.forEach((node, index) => {
                    node.position({
                        x: rightX,
                        y: startY + index * slaveSpacing
                    });
                });
            }
        }

        // Initialize Cytoscape
        function initCytoscape() {
            cy = cytoscape({
                container: document.getElementById('cy'),
                elements: [],
                style: [
                    {
                        selector: 'node',
                        style: {
                            'label': 'data(label)',
                            'width': '60px',
                            'height': 'data(height)',
                            'shape': 'round-rectangle',
                            'background-color': '#e8e8e8',
                            'background-image': 'data(progressBg)',
                            'background-width': '100%',
                            'background-height': '100%',
                            'background-fit': 'cover',
                            'background-position-x': '0%',
                            'background-position-y': '100%',
                            'border-width': 2,
                            'border-color': '#888',
                            'text-valign': 'center',
                            'text-halign': 'center',
                            'font-size': '12px',
                            'font-weight': 'bold',
                            'color': '#333',
                            'text-wrap': 'wrap',
                            'text-max-width': '80px'
                        }
                    },
                    {
                        selector: 'node[type="RN"], node[type="master"]',
                        style: {
                            'background-color': '#4a9eff',
                            'border-color': '#0066cc',
                            'color': 'white'
                        }
                    },
                    {
                        selector: 'node[type="SN"], node[type="slave"]',
                        style: {
                            'background-color': '#52c41a',
                            'border-color': '#389e0d',
                            'color': 'white'
                        }
                    },
                    {
                        selector: 'node[type="HN"], node[type="relay"]',
                        style: {
                            'background-color': '#ff7a45',
                            'border-color': '#d4380d',
                            'color': 'white'
                        }
                    },
                    {
                        selector: 'edge',
                        style: {
                            'width': 2,
                            'line-color': '#999',
                            'target-arrow-color': '#999',
                            'target-arrow-shape': 'triangle',
                            'curve-style': 'bezier',
                            'label': 'data(label)',
                            'font-size': '10px',
                            'text-rotation': 'autorotate',
                            'text-margin-y': -10
                        }
                    },
                    {
                        selector: 'edge[label="Req"], edge[label="request"]',
                        style: {
                            'line-color': '#4a9eff',
                            'target-arrow-color': '#4a9eff'
                        }
                    },
                    {
                        selector: 'edge[label="Comp"], edge[label="response"]',
                        style: {
                            'line-color': '#52c41a',
                            'target-arrow-color': '#52c41a'
                        }
                    },
                    {
                        selector: 'edge[label="forward"]',
                        style: {
                            'line-color': '#ff7a45',
                            'target-arrow-color': '#ff7a45'
                        }
                    },
                    {
                        selector: 'edge[label="return"]',
                        style: {
                            'line-color': '#faad14',
                            'target-arrow-color': '#faad14'
                        }
                    }
                ]
            });

            // Add hover tooltip for nodes
            cy.on('mouseover', 'node', function(evt) {
                const node = evt.target;
                const data = node.data();
                let tooltip = `${data.label}\nID: ${data.id}\nType: ${data.type}`;
                
                // Display CHI protocol information
                if (data.payload && data.payload.chiProtocol) {
                    const nodeTypeMap = {'RN': 'Request Node (CHI)', 'HN': 'Home Node (CHI)', 'SN': 'Slave Node (CHI)'};
                    const chiType = data.payload.nodeType || data.type;
                    tooltip += `\nCHI Protocol: ${nodeTypeMap[chiType] || chiType}`;
                }
                
                if (data.queues && data.queues.length > 0) {
                    tooltip += '\n\nQueues:';
                    data.queues.forEach(q => {
                        const cap = q.capacity === -1 ? '∞' : q.capacity;
                        tooltip += `\n${q.name}: ${q.length}/${cap}`;
                    });
                }

                if (data.payload) {
                    tooltip += '\n\nStats:';
                    for (const [key, value] of Object.entries(data.payload)) {
                        // Skip internal CHI protocol fields in tooltip
                        if (key === 'chiProtocol' || key === 'nodeType') continue;
                        if (typeof value === 'number') {
                            tooltip += `\n${key}: ${value.toFixed(2)}`;
                        } else {
                            tooltip += `\n${key}: ${value}`;
                        }
                    }
                }

                node.qtip({
                    content: tooltip,
                    position: {
                        my: 'top center',
                        at: 'bottom center'
                    },
                    style: {
                        classes: 'qtip-bootstrap',
                        tip: {
                            width: 16,
                            height: 8
                        }
                    },
                    show: {
                        event: 'mouseover',
                        ready: true
                    },
                    hide: {
                        event: 'mouseout'
                    }
                }, evt);
            });

            // Add click event for nodes to show packet information
            cy.on('tap', 'node', function(evt) {
                const node = evt.target;
                const data = node.data();
                showPacketModal(data);
            });

            // Add hover tooltip for edges to show pipeline stages
            cy.on('mouseover', 'edge', function(evt) {
                const edge = evt.target;
                const data = edge.data();
                let tooltip = `${data.label}\nSource: ${data.source} → Target: ${data.target}`;
                
                if (data.pipelineStages && data.pipelineStages.length > 0) {
                    tooltip += '\n\nPipeline Stages:';
                    data.pipelineStages.forEach(stage => {
                        tooltip += `\nStage ${stage.stageIndex}: ${stage.packetCount} packet(s)`;
                    });
                    
                    // Indicate potential backpressure if Slot[0] has packets
                    if (data.pipelineStages[0] && data.pipelineStages[0].packetCount > 0) {
                        tooltip += '\n\n⚠ Slot[0] has packets (may indicate backpressure)';
                    }
                } else {
                    tooltip += '\n\nNo pipeline data available';
                }

                edge.qtip({
                    content: tooltip,
                    position: {
                        my: 'top center',
                        at: 'bottom center'
                    },
                    style: {
                        classes: 'qtip-bootstrap',
                        tip: {
                            width: 16,
                            height: 8
                        }
                    },
                    show: {
                        event: 'mouseover',
                        ready: true
                    },
                    hide: {
                        event: 'mouseout'
                    }
                }, evt);
            });

            // Update pipeline state points when view changes (pan, zoom, render)
            cy.on('render', function() {
                if (currentFrame) {
                    drawPipelineStatePoints(currentFrame);
                }
            });
        }

        // Format CHI protocol field values for display
        function formatCHIField(field, value) {
            if (value === undefined || value === null || value === '') {
                return 'N/A';
            }
            
            if (field === 'transactionType') {
                const typeMap = {
                    'ReadNoSnp': 'ReadNoSnp',
                    'WriteNoSnp': 'WriteNoSnp',
                    'ReadOnce': 'ReadOnce',
                    'WriteUnique': 'WriteUnique'
                };
                return typeMap[value] || value;
            }
            
            if (field === 'messageType') {
                const typeMap = {
                    'Req': 'Request',
                    'Resp': 'Response',
                    'Data': 'Data',
                    'Comp': 'Completion'
                };
                return typeMap[value] || value;
            }
            
            if (field === 'responseType') {
                const typeMap = {
                    'CompData': 'CompData (Completion with Data)',
                    'CompAck': 'CompAck (Completion Acknowledgment)'
                };
                return typeMap[value] || value;
            }
            
            if (field === 'address') {
                return '0x' + value.toString(16).toUpperCase().padStart(16, '0');
            }
            
            if (field === 'type') {
                return value.charAt(0).toUpperCase() + value.slice(1);
            }
            
            return value;
        }

        // Format packet information for display
        function formatPacketInfo(packet) {
            const fields = [
                { label: 'Packet ID', key: 'id', format: (v) => v },
                { label: 'Type', key: 'type', format: (v) => formatCHIField('type', v) },
                { label: 'Source Node ID', key: 'srcID', format: (v) => v !== undefined ? v : 'N/A' },
                { label: 'Destination Node ID', key: 'dstID', format: (v) => v !== undefined ? v : 'N/A' },
                { label: 'Master ID', key: 'masterID', format: (v) => v !== undefined ? v : 'N/A' },
                { label: 'Request ID', key: 'requestID', format: (v) => v !== undefined ? v : 'N/A' },
                { label: 'Transaction Type', key: 'transactionType', format: (v) => formatCHIField('transactionType', v) },
                { label: 'Message Type', key: 'messageType', format: (v) => formatCHIField('messageType', v) },
                { label: 'Response Type', key: 'responseType', format: (v) => formatCHIField('responseType', v) },
                { label: 'Address', key: 'address', format: (v) => v !== undefined ? formatCHIField('address', v) : 'N/A' },
                { label: 'Data Size (bytes)', key: 'dataSize', format: (v) => v !== undefined ? v : 'N/A' },
                { label: 'Generated At (cycle)', key: 'generatedAt', format: (v) => v !== undefined && v !== 0 ? v : 'N/A' },
                { label: 'Sent At (cycle)', key: 'sentAt', format: (v) => v !== undefined && v !== 0 ? v : 'N/A' },
                { label: 'Received At (cycle)', key: 'receivedAt', format: (v) => v !== undefined && v !== 0 ? v : 'N/A' },
                { label: 'Completed At (cycle)', key: 'completedAt', format: (v) => v !== undefined && v !== 0 ? v : 'N/A' }
            ];
            
            let html = '<table class="packet-table">';
            fields.forEach(field => {
                const value = packet[field.key];
                if (value !== undefined && value !== null && value !== '') {
                    html += `<tr><td class="packet-field-label">${field.label}:</td><td class="packet-field-value">${field.format(value)}</td></tr>`;
                }
            });
            html += '</table>';
            return html;
        }

        // Show packet modal with node information
        function showPacketModal(nodeData) {
            const modal = document.getElementById('packetModal');
            const modalTitle = document.getElementById('modalTitle');
            const modalBody = document.getElementById('modalBody');
            
            modalTitle.textContent = `${nodeData.label || 'Node'} - Packet Information`;
            
            let html = '';
            
            if (!nodeData.queues || nodeData.queues.length === 0) {
                html = '<div class="queue-section empty">No queues found for this node.</div>';
            } else {
                nodeData.queues.forEach(queue => {
                    html += `<div class="queue-section">`;
                    html += `<h3>${queue.name} (${queue.length}/${queue.capacity === -1 ? '∞' : queue.capacity})</h3>`;
                    
                    if (!queue.packets || queue.packets.length === 0) {
                        html += '<div class="empty">This queue is empty.</div>';
                    } else {
                        queue.packets.forEach((packet, index) => {
                            html += `<div class="packet-item">`;
                            html += `<div class="packet-item-header">Packet #${index + 1} (ID: <span class="packet-id">${packet.id}</span>)</div>`;
                            html += `<div class="packet-item-body">`;
                            html += formatPacketInfo(packet);
                            html += `</div></div>`;
                        });
                    }
                    
                    html += `</div>`;
                });
            }
            
            modalBody.innerHTML = html;
            modal.classList.add('show');
        }

        // Close modal
        function closePacketModal() {
            const modal = document.getElementById('packetModal');
            modal.classList.remove('show');
        }

        // Calculate a point on the bezier curve at parameter t (0 to 1)
        function calculateBezierPoint(cyEdge, t) {
            if (!cyEdge || cyEdge.length === 0) {
                return null;
            }

            const source = cyEdge.source();
            const target = cyEdge.target();
            const sourcePos = source.renderedPosition();
            const targetPos = target.renderedPosition();

            // For bezier curves, Cytoscape uses control points
            // We'll approximate the curve by using a quadratic bezier with a control point
            const midX = (sourcePos.x + targetPos.x) / 2;
            const midY = (sourcePos.y + targetPos.y) / 2;
            
            // Calculate perpendicular offset for bezier control point
            const dx = targetPos.x - sourcePos.x;
            const dy = targetPos.y - sourcePos.y;
            const length = Math.sqrt(dx * dx + dy * dy);
            
            if (length === 0) {
                return { x: sourcePos.x, y: sourcePos.y };
            }
            
            // Perpendicular vector (rotated 90 degrees)
            const perpX = -dy / length;
            const perpY = dx / length;
            
            // Control point offset (adjust curve height)
            const curveOffset = Math.min(length * 0.3, 50);
            const controlX = midX + perpX * curveOffset;
            const controlY = midY + perpY * curveOffset;

            // Quadratic bezier formula: (1-t)^2*P0 + 2*(1-t)*t*P1 + t^2*P2
            const x = (1 - t) * (1 - t) * sourcePos.x + 2 * (1 - t) * t * controlX + t * t * targetPos.x;
            const y = (1 - t) * (1 - t) * sourcePos.y + 2 * (1 - t) * t * controlY + t * t * targetPos.y;
            
            return { x, y };
        }

        // Calculate points along a bezier curve for an edge (for calculating perpendicular direction)
        function calculateBezierPoints(cyEdge, numPoints) {
            const points = [];
            for (let i = 0; i <= numPoints; i++) {
                const t = i / numPoints;
                const point = calculateBezierPoint(cyEdge, t);
                if (point) {
                    points.push(point);
                }
            }
            return points;
        }

        // Calculate perpendicular direction at a point on the curve at parameter t
        function calculatePerpendicularAtT(cyEdge, t) {
            const dt = 0.01; // Small delta for calculating tangent
            const t1 = Math.max(0, t - dt);
            const t2 = Math.min(1, t + dt);
            
            const p1 = calculateBezierPoint(cyEdge, t1);
            const p2 = calculateBezierPoint(cyEdge, t2);
            
            if (!p1 || !p2) {
                return { x: 0, y: 1 }; // Default vertical
            }
            
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            const length = Math.sqrt(dx * dx + dy * dy);
            
            if (length === 0) {
                return { x: 0, y: 1 };
            }

            // Perpendicular vector (rotated 90 degrees clockwise)
            return {
                x: dy / length,
                y: -dx / length
            };
        }

        // Draw pipeline state points on edges
        function drawPipelineStatePoints(frame) {
            if (!frame || !frame.edges || !cy) {
                return;
            }

            const overlay = document.getElementById('pipelineOverlay');
            if (!overlay) {
                return;
            }

            // Clear existing points
            overlay.innerHTML = '';

            // Get container position for coordinate conversion
            const container = document.getElementById('cy');
            const containerRect = container.getBoundingClientRect();
            const cyPan = cy.pan();
            const cyZoom = cy.zoom();

            frame.edges.forEach(edge => {
                const edgeId = `e${edge.source}-${edge.target}`;
                const cyEdge = cy.getElementById(edgeId);
                
                if (cyEdge.length === 0) {
                    return;
                }

                // Get data from both frame edge and Cytoscape edge (Cytoscape edge has the latest data)
                const edgeData = cyEdge.data();
                const latency = edgeData.latency || edge.latency || 1;
                const bandwidthLimit = edgeData.bandwidthLimit || edge.bandwidthLimit || 1;
                const pipelineStages = edgeData.pipelineStages || edge.pipelineStages || [];

                // Calculate points along the bezier curve
                const curvePoints = calculateBezierPoints(cyEdge, latency);
                
                if (curvePoints.length === 0) {
                    return;
                }

                // Create a mapping of stageIndex to PacketCount
                const stageMap = {};
                pipelineStages.forEach(stage => {
                    stageMap[stage.stageIndex] = stage.packetCount;
                });

                // Draw points for each stage
                for (let stageIdx = 0; stageIdx < latency; stageIdx++) {
                    // Calculate point position along the curve
                    // Adjust positions to avoid overlapping with nodes while maintaining semantic meaning
                    // Slot[0] (first stage) should be near source, Slot[latency-1] (last stage) near target
                    let t;
                    if (latency === 1) {
                        t = 0.5; // Single stage in the middle
                    } else {
                        // Distribute points from 40% to 60% of the curve to avoid node overlap
                        // Map stageIdx from [0, latency-1] to [0.4, 0.6]
                        // This ensures no point is at t=0 (source node) or t=1 (target node)
                        t = 0.4 + (stageIdx / (latency - 1)) * 0.2;
                    }
                    
                    // Directly calculate the point on the curve at parameter t
                    const curvePoint = calculateBezierPoint(cyEdge, t);
                    if (!curvePoint) {
                        continue;
                    }
                    
                    // Calculate perpendicular direction at this point
                    const perpDir = calculatePerpendicularAtT(cyEdge, t);

                    // renderedPosition() already returns viewport coordinates (with zoom and pan applied)
                    // Since SVG overlay is positioned absolutely over the Cytoscape container, we can use these coordinates directly
                    const viewportX = curvePoint.x;
                    const viewportY = curvePoint.y;

                    const packetCount = stageMap[stageIdx] || 0;
                    const pointSpacing = 4; // Spacing between points in perpendicular direction
                    const totalWidth = (bandwidthLimit - 1) * pointSpacing;
                    const startOffset = -totalWidth / 2;

                    // Draw points for this stage
                    for (let i = 0; i < bandwidthLimit; i++) {
                        const offsetX = startOffset + i * pointSpacing;
                        const pointX = viewportX + perpDir.x * offsetX;
                        const pointY = viewportY + perpDir.y * offsetX;

                        const isFilled = i < packetCount;
                        const color = isFilled ? '#ff4d4f' : '#999';
                        const radius = 3;

                        // Create circle element
                        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        circle.setAttribute('cx', pointX);
                        circle.setAttribute('cy', pointY);
                        circle.setAttribute('r', radius);
                        circle.setAttribute('fill', color);
                        circle.setAttribute('stroke', '#fff');
                        circle.setAttribute('stroke-width', '0.5');
                        overlay.appendChild(circle);
                    }
                }
            });

            // Update SVG size to match container
            overlay.setAttribute('width', containerRect.width);
            overlay.setAttribute('height', containerRect.height);
        }

        // Fetch frame data from API
        async function fetchFrame() {
            try {
                const response = await fetch('/api/frame');
                if (!response.ok) {
                    if (response.status === 404) {
                        return null; // No frame available yet
                    }
                    throw new Error(`HTTP ${response.status}`);
                }
                const frame = await response.json();
                return frame;
            } catch (error) {
                console.error('Error fetching frame:', error);
                showError('Failed to fetch simulation data: ' + error.message);
                return null;
            }
        }

        // Update visualization with frame data
        function updateVisualization(frame) {
            if (!frame || !frame.nodes || !frame.edges) {
                return;
            }

            currentFrame = frame;

            // Update status info
            document.getElementById('currentCycle').textContent = frame.cycle || 0;
            document.getElementById('inFlightCount').textContent = frame.inFlightCount || 0;
            
            const statusEl = document.getElementById('simStatus');
            if (frame.cycle >= (frame.totalCycles || 1000)) {
                statusEl.innerHTML = 'Status: <strong style="color: #52c41a;">Completed</strong>';
            } else {
                statusEl.innerHTML = 'Status: <strong style="color: #1890ff;">Running</strong>';
            }

            // Update button states based on current pause status
            updateButtonStates();

            // Initialize topology on first frame
            if (!topologyInitialized) {
                const elements = [];

                // Add nodes
                frame.nodes.forEach(node => {
                    const queues = node.queues || [];
                    const nodeWidth = 60;
                    const baseHeight = 60;
                    const progressBarHeight = queues.length > 0 ? queues.length * 3 + (queues.length - 1) * 1 + 4 : 0;
                    const nodeHeight = baseHeight + progressBarHeight;
                    
                    const progressBg = createProgressBarsSVG(queues, nodeWidth, nodeHeight);
                    
                    const nodeData = {
                        group: 'nodes',
                        data: {
                            id: String(node.id),
                            label: node.label || `Node ${node.id}`,
                            type: node.type,
                            queues: queues,
                            payload: node.payload || {},
                            height: nodeHeight,
                            progressBg: progressBg
                        }
                    };
                    elements.push(nodeData);
                });

                // Add edges
                frame.edges.forEach(edge => {
                    const edgeLabel = `${edge.label} (${edge.latency}cy)`;
                    const pipelineStages = edge.pipelineStages || [];
                    elements.push({
                        group: 'edges',
                        data: {
                            id: `e${edge.source}-${edge.target}`,
                            source: String(edge.source),
                            target: String(edge.target),
                            label: edgeLabel,
                            latency: edge.latency,
                            pipelineStages: pipelineStages,
                            bandwidthLimit: edge.bandwidthLimit
                        }
                    });
                });

                // Add all elements
                cy.add(elements);
                
                // Apply custom layout after elements are added
                // Use setTimeout to ensure Cytoscape has processed the elements
                setTimeout(() => {
                    applyCustomLayout();
                }, 50);
                
                topologyInitialized = true;
            }

            // Update existing nodes with new data (without re-layout)
            frame.nodes.forEach(node => {
                const nodeId = String(node.id);
                const cyNode = cy.getElementById(nodeId);
                
                if (cyNode.length > 0) {
                    const queues = node.queues || [];
                    const nodeWidth = 60;
                    const baseHeight = 60;
                    const progressBarHeight = queues.length > 0 ? queues.length * 3 + (queues.length - 1) * 1 + 4 : 0;
                    const nodeHeight = baseHeight + progressBarHeight;
                    
                    const progressBg = createProgressBarsSVG(queues, nodeWidth, nodeHeight);
                    
                    // Update node data
                    let label = node.label || `Node ${node.id}`;
                    if (queues.length > 0) {
                        const queueInfo = queues.map(q => {
                            const cap = q.capacity === -1 ? '∞' : q.capacity;
                            return `${q.name}:${q.length}/${cap}`;
                        }).join(' ');
                        label += `\n${queueInfo}`;
                    }

                    cyNode.data({
                        label: label,
                        queues: queues,
                        payload: node.payload || {},
                        height: nodeHeight,
                        progressBg: progressBg
                    });
                }
            });

            // Update existing edges with pipeline stages
            frame.edges.forEach(edge => {
                const edgeId = `e${edge.source}-${edge.target}`;
                const cyEdge = cy.getElementById(edgeId);
                
                if (cyEdge.length > 0) {
                    const pipelineStages = edge.pipelineStages || [];
                    let edgeLabel = `${edge.label} (${edge.latency}cy)`;
                    
                    // Add pipeline stages info to label if available
                    if (pipelineStages.length > 0) {
                        const stageInfo = pipelineStages.map(s => `S${s.stageIndex}:${s.packetCount}`).join(' ');
                        edgeLabel += `\n[${stageInfo}]`;
                    }
                    
                    cyEdge.data({
                        label: edgeLabel,
                        pipelineStages: pipelineStages,
                        bandwidthLimit: edge.bandwidthLimit
                    });
                    
                    // Update edge style based on backpressure (Slot[0] has packets but can't advance)
                    if (pipelineStages.length > 0 && pipelineStages[0].packetCount > 0) {
                        // Check if this indicates backpressure (would need receiver state, simplified here)
                        cyEdge.style('line-color', '#ff4d4f'); // Red for potential backpressure
                        cyEdge.style('width', 3);
                    } else {
                        cyEdge.style('line-color', '#91d5ff'); // Blue for normal
                        cyEdge.style('width', 2);
                    }
                }
            });

            // Draw pipeline state points
            drawPipelineStatePoints(frame);

            // Update statistics
            updateStatistics(frame.stats);
        }

        // Update statistics panel
        function updateStatistics(stats) {
            const panel = document.getElementById('statsPanel');
            if (!stats || !stats.Global) {
                panel.innerHTML = '<div class="stats-item"><div style="text-align: center; color: #999;">No data available</div></div>';
                return;
            }

            let html = '';

            // Global stats
            html += '<div class="stats-item">';
            html += '<h4>Global Statistics</h4>';
            html += '<div class="stats-grid">';
            html += `<div class="stats-value">Total Requests: <strong>${stats.Global.TotalRequests}</strong></div>`;
            html += `<div class="stats-value">Completed: <strong>${stats.Global.Completed}</strong></div>`;
            html += `<div class="stats-value">Completion Rate: <strong>${stats.Global.CompletionRate.toFixed(2)}%</strong></div>`;
            html += `<div class="stats-value">Avg Delay: <strong>${stats.Global.AvgEndToEndDelay.toFixed(2)} cy</strong></div>`;
            html += `<div class="stats-value">Max Delay: <strong>${stats.Global.MaxDelay} cy</strong></div>`;
            html += `<div class="stats-value">Min Delay: <strong>${stats.Global.MinDelay} cy</strong></div>`;
            html += '</div>';
            html += '</div>';

            // Master stats
            if (stats.PerMaster && stats.PerMaster.length > 0) {
                html += '<div class="stats-item">';
                html += '<h4>Master Statistics</h4>';
                stats.PerMaster.forEach((m, idx) => {
                    if (m) {
                        html += `<div style="margin-top: 6px; padding-top: 6px; border-top: 1px solid #eee;">`;
                        html += `<strong>Master ${idx}</strong><br>`;
                        html += `Completed: ${m.CompletedRequests}, `;
                        html += `Avg Delay: ${m.AvgDelay.toFixed(2)} cy, `;
                        html += `Max: ${m.MaxDelay} cy, Min: ${m.MinDelay} cy`;
                        html += '</div>';
                    }
                });
                html += '</div>';
            }

            // Slave stats
            if (stats.PerSlave && stats.PerSlave.length > 0) {
                html += '<div class="stats-item">';
                html += '<h4>Slave Statistics</h4>';
                stats.PerSlave.forEach((s, idx) => {
                    if (s) {
                        html += `<div style="margin-top: 6px; padding-top: 6px; border-top: 1px solid #eee;">`;
                        html += `<strong>Slave ${idx}</strong><br>`;
                        html += `Processed: ${s.TotalProcessed}, `;
                        html += `Max Queue: ${s.MaxQueueLength}, `;
                        html += `Avg Queue: ${s.AvgQueueLength.toFixed(2)}`;
                        html += '</div>';
                    }
                });
                html += '</div>';
            }

            panel.innerHTML = html;
        }

        // Send control command
        async function sendControl(type, configName, totalCycles) {
            try {
                const body = { type: type };
                if (configName) {
                    body.configName = configName;
                }
                if (totalCycles !== undefined && totalCycles !== null) {
                    body.totalCycles = totalCycles;
                }

                const response = await fetch('/api/control', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(body)
                });

                if (!response.ok) {
                    const text = await response.text();
                    throw new Error(text || `HTTP ${response.status}`);
                }

                hideError();
                return true;
            } catch (error) {
                console.error('Error sending control:', error);
                showError('Failed to send command: ' + error.message);
                return false;
            }
        }

        // Load available network configurations
        async function loadConfigurations() {
            try {
                const response = await fetch('/api/configs');
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                const configs = await response.json();
                
                const select = document.getElementById('networkConfig');
                select.innerHTML = '';
                
                if (configs.length === 0) {
                    select.innerHTML = '<option value="">No configurations available</option>';
                    return;
                }
                
                configs.forEach((cfg, index) => {
                    const option = document.createElement('option');
                    option.value = cfg.name;
                    option.textContent = cfg.description;
                    if (index === 0) {
                        option.selected = true;
                    }
                    select.appendChild(option);
                });
            } catch (error) {
                console.error('Error loading configurations:', error);
                const select = document.getElementById('networkConfig');
                select.innerHTML = '<option value="">Error loading configurations</option>';
                showError('Failed to load network configurations: ' + error.message);
            }
        }

        // Get selected configuration name from form
        function getConfigFromForm() {
            const select = document.getElementById('networkConfig');
            return select.value;
        }

        // Validate configuration
        function validateConfig(configName) {
            if (!configName) {
                return 'Please select a network configuration';
            }
            const totalCycles = parseInt(document.getElementById('totalCycles').value);
            if (isNaN(totalCycles) || totalCycles <= 0) {
                return 'TotalCycles must be a positive number';
            }
            return null;
        }

        // Show error message
        function showError(message) {
            const errorEl = document.getElementById('errorMessage');
            errorEl.textContent = message;
            errorEl.classList.add('show');
        }

        // Hide error message
        function hideError() {
            const errorEl = document.getElementById('errorMessage');
            errorEl.classList.remove('show');
        }

        // Start polling for frames
        function startPolling() {
            if (pollInterval) {
                clearInterval(pollInterval);
            }
            pollInterval = setInterval(async () => {
                // Poll regardless of pause state to get updates after step commands
                const frame = await fetchFrame();
                if (frame) {
                    updateVisualization(frame);
                }
            }, 500); // Poll every 500ms
        }

        // Stop polling
        function stopPolling() {
            if (pollInterval) {
                clearInterval(pollInterval);
                pollInterval = null;
            }
        }

        // Update button states based on pause status
        function updateButtonStates() {
            const btnPause = document.getElementById('btnPause');
            const btnResume = document.getElementById('btnResume');
            const btnStep = document.getElementById('btnStep');
            
            if (btnPause) {
                btnPause.disabled = isPaused; // Disable when paused
            }
            if (btnResume) {
                btnResume.disabled = !isPaused; // Disable when running
            }
            if (btnStep) {
                btnStep.disabled = !isPaused; // Enable only when paused
            }
        }

        // Event listeners
        document.getElementById('btnPause').addEventListener('click', async () => {
            const success = await sendControl('pause');
            if (success) {
                isPaused = true;
                updateButtonStates();
            }
        });

        document.getElementById('btnResume').addEventListener('click', async () => {
            const success = await sendControl('resume');
            if (success) {
                isPaused = false;
                updateButtonStates();
            }
        });

        document.getElementById('btnStep').addEventListener('click', async () => {
            if (!isPaused) {
                return; // Step button should only work when paused
            }
            const success = await sendControl('step');
            if (success) {
                // Step command sent, state remains paused
                // Frame will be updated on next poll
            }
        });

        document.getElementById('btnReset').addEventListener('click', async () => {
            const configName = getConfigFromForm();
            const error = validateConfig(configName);
            if (error) {
                showError(error);
                return;
            }
            const totalCycles = parseInt(document.getElementById('totalCycles').value);
            const success = await sendControl('reset', configName, totalCycles);
            if (success) {
                isPaused = true; // Reset pauses at cycle 0
                updateButtonStates();
                // Clear visualization and reset topology
                cy.elements().remove();
                topologyInitialized = false;
                document.getElementById('currentCycle').textContent = '-';
                document.getElementById('inFlightCount').textContent = '-';
                document.getElementById('simStatus').innerHTML = 'Status: <strong>Resetting...</strong>';
            }
        });

        // Initialize
        loadConfigurations();
        initCytoscape();
        updateButtonStates(); // Set initial button states (paused at cycle 0)
        startPolling();

        // Modal close event listeners (initialize after DOM is ready)
        document.getElementById('modalClose').addEventListener('click', closePacketModal);
        document.getElementById('packetModal').addEventListener('click', function(e) {
            if (e.target === this) {
                closePacketModal();
            }
        });

        // Reapply layout on window resize
        let resizeTimeout;
        window.addEventListener('resize', () => {
            if (topologyInitialized) {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    applyCustomLayout();
                }, 250);
            }
        });

        // Initial frame fetch
        fetchFrame().then(frame => {
            if (frame) {
                updateVisualization(frame);
            }
        });
    </script>
</body>
</html>

