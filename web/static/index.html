<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flow Control Simulator - Visualization</title>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/qtip2@3.0.3/dist/jquery.qtip.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/qtip2@3.0.3/dist/jquery.qtip.min.css">
    <script src="https://cdn.jsdelivr.net/npm/cytoscape@3.27.0/dist/cytoscape.min.js"></script>
    <script src="https://unpkg.com/cytoscape-qtip@2.8.0/cytoscape-qtip.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        .control-panel {
            width: 350px;
            background: #f5f5f5;
            border-right: 1px solid #ddd;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        .control-section {
            padding: 15px;
            border-bottom: 1px solid #ddd;
        }

        .control-section h3 {
            margin-bottom: 10px;
            color: #333;
            font-size: 14px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .control-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        button {
            padding: 8px 16px;
            border: 1px solid #ccc;
            background: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }

        button:hover:not(:disabled) {
            background: #f0f0f0;
            border-color: #999;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        button.primary {
            background: #007bff;
            color: white;
            border-color: #007bff;
        }

        button.primary:hover:not(:disabled) {
            background: #0056b3;
        }

        button.danger {
            background: #dc3545;
            color: white;
            border-color: #dc3545;
        }

        button.danger:hover:not(:disabled) {
            background: #c82333;
        }

        .status-info {
            font-size: 12px;
            color: #666;
            margin-top: 8px;
        }

        .status-info strong {
            color: #333;
        }

        .config-form {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .form-group label {
            font-size: 12px;
            color: #666;
            font-weight: 500;
        }

        .form-group input {
            padding: 6px 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 13px;
        }

        .form-group input:focus {
            outline: none;
            border-color: #007bff;
        }

        .form-row {
            display: flex;
            gap: 10px;
        }

        .form-row .form-group {
            flex: 1;
        }

        .stats-panel {
            max-height: 400px;
            overflow-y: auto;
        }

        .stats-item {
            padding: 8px;
            background: white;
            border-radius: 4px;
            margin-bottom: 8px;
            font-size: 12px;
        }

        .stats-item h4 {
            margin-bottom: 6px;
            color: #333;
            font-size: 13px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            margin-top: 6px;
        }

        .stats-value {
            color: #666;
        }

        .stats-value strong {
            color: #333;
        }

        .visualization-area {
            flex: 1;
            position: relative;
            background: #fff;
        }

        #cy {
            width: 100%;
            height: 100%;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 20px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            z-index: 1000;
        }

        .error-message {
            padding: 10px;
            background: #fee;
            border: 1px solid #fcc;
            border-radius: 4px;
            color: #c33;
            font-size: 12px;
            margin-top: 10px;
            display: none;
        }

        .error-message.show {
            display: block;
        }

        .queue-info {
            font-size: 11px;
            color: #666;
            margin-top: 4px;
        }

        /* Modal styles */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 10000;
            justify-content: center;
            align-items: center;
        }

        .modal-overlay.show {
            display: flex;
        }

        .modal-content {
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            max-width: 800px;
            max-height: 90vh;
            width: 90%;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .modal-header {
            padding: 20px;
            border-bottom: 1px solid #ddd;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #f5f5f5;
        }

        .modal-header h2 {
            margin: 0;
            font-size: 18px;
            color: #333;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #666;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
        }

        .modal-close:hover {
            background: #e0e0e0;
            color: #333;
        }

        .modal-body {
            padding: 20px;
            overflow-y: auto;
            flex: 1;
        }

        .queue-section {
            margin-bottom: 30px;
        }

        .queue-section h3 {
            font-size: 16px;
            color: #333;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 2px solid #007bff;
        }

        .queue-section.empty {
            color: #999;
            font-style: italic;
            padding: 20px;
            text-align: center;
        }

        .packet-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
            font-size: 13px;
        }

        .packet-table th {
            background: #f5f5f5;
            padding: 10px;
            text-align: left;
            border-bottom: 2px solid #ddd;
            font-weight: 600;
            color: #333;
        }

        .packet-table td {
            padding: 10px;
            border-bottom: 1px solid #eee;
        }

        .packet-table tr:hover {
            background: #f9f9f9;
        }

        .packet-id {
            font-weight: 600;
            color: #007bff;
        }

        .packet-field-label {
            font-weight: 500;
            color: #666;
            width: 150px;
        }

        .packet-field-value {
            color: #333;
        }

        .packet-item {
            margin-bottom: 20px;
            border: 1px solid #ddd;
            border-radius: 4px;
            overflow: hidden;
        }

        .packet-item-header {
            background: #f5f5f5;
            padding: 10px 15px;
            font-weight: 600;
            color: #333;
            border-bottom: 1px solid #ddd;
        }

        .packet-item-body {
            padding: 15px;
        }

        @media (max-width: 768px) {
            body {
                flex-direction: column;
            }

            .control-panel {
                width: 100%;
                max-height: 40vh;
            }
        }
    </style>
</head>
<body>
    <div class="control-panel">
        <div class="control-section">
            <h3>Simulation Control</h3>
            <div class="control-buttons">
                <button id="btnPause" class="primary">Pause</button>
                <button id="btnResume" class="primary">Resume</button>
                <button id="btnStep" class="primary">Step</button>
                <button id="btnReset" class="danger">Reset</button>
            </div>
            <div class="status-info">
                <div>Cycle: <strong id="currentCycle">-</strong></div>
                <div>In-Flight: <strong id="inFlightCount">-</strong></div>
                <div id="simStatus">Status: <strong>Waiting</strong></div>
            </div>
            <div id="errorMessage" class="error-message"></div>
        </div>

        <div class="control-section">
            <h3>Configuration</h3>
            <div class="config-form">
                <div class="form-group">
                    <label>Network Configuration</label>
                    <select id="networkConfig" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                        <option value="">Loading configurations...</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Total Cycles</label>
                    <input type="number" id="totalCycles" min="1" value="1000">
                </div>
            </div>
            <div class="status-info" style="margin-top: 10px; font-size: 11px; color: #999;">
                Select a predefined network configuration. Changes take effect after Reset.
            </div>
        </div>

        <div class="control-section">
            <h3>Statistics</h3>
            <div class="stats-panel" id="statsPanel">
                <div class="stats-item">
                    <div style="text-align: center; color: #999;">No data available</div>
                </div>
            </div>
        </div>
    </div>

    <div class="visualization-area">
        <div id="cy"></div>
        <svg id="pipelineOverlay" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10;"></svg>
        <div id="loading" class="loading" style="display: none;">
            <div>Loading simulation data...</div>
        </div>
    </div>

    <!-- Modal for displaying packet information -->
    <div id="packetModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modalTitle">Node Packet Information</h2>
                <button class="modal-close" id="modalClose">&times;</button>
            </div>
            <div class="modal-body" id="modalBody">
                <!-- Content will be populated by JavaScript -->
            </div>
        </div>
    </div>

    <script>
        let cy;
        let ws = null; // WebSocket connection
        let wsReconnectTimeout = null;
        let isPaused = true; // Web mode starts paused at cycle 0
        let currentFrame = null;
        let topologyInitialized = false;
        let currentConfigName = null; // Track current network configuration name
        let lastConfigHash = null; // Track last config hash from frame to detect config changes
        let expectingReset = false; // Track if we're waiting for a reset frame (cycle 0)
        let isStepProcessing = false; // Track if a step command is being processed

        // Calculate load percentage for a queue
        function calculateQueueLoad(queue) {
            if (!queue || queue.capacity === -1 || queue.capacity === 0) {
                return 0; // Unlimited capacity or invalid capacity
            }
            const load = Math.min(100, Math.max(0, (queue.length / queue.capacity) * 100));
            return load;
        }

        // Get color for load percentage
        function getLoadColor(percentage) {
            if (percentage < 50) {
                return '#52c41a'; // Green for low load
            } else if (percentage < 80) {
                return '#faad14'; // Yellow for medium load
            } else {
                return '#ff4d4f'; // Red for high load
            }
        }

        // Create progress bar SVG for multiple queues
        function createProgressBarsSVG(queues, nodeWidth, nodeHeight) {
            if (!queues || queues.length === 0) {
                return 'none';
            }

            const progressBarHeight = 3;
            const progressBarSpacing = 1;
            const totalProgressHeight = queues.length * progressBarHeight + (queues.length - 1) * progressBarSpacing;
            const padding = 2;
            const startY = nodeHeight - totalProgressHeight - padding;

            let svgParts = [];
            
            // Draw transparent background for the entire node (so the original background color shows through)
            svgParts.push(`<rect x="0" y="0" width="${nodeWidth}" height="${nodeHeight}" fill="transparent"/>`);
            
            queues.forEach((queue, index) => {
                const load = calculateQueueLoad(queue);
                const y = startY + index * (progressBarHeight + progressBarSpacing);
                const progressWidth = (load / 100) * nodeWidth;
                const color = getLoadColor(load);

                // Background bar (gray, semi-transparent)
                svgParts.push(`<rect x="0" y="${y}" width="${nodeWidth}" height="${progressBarHeight}" fill="#e0e0e0" opacity="0.6" rx="1"/>`);
                
                // Progress bar (colored)
                if (progressWidth > 0) {
                    svgParts.push(`<rect x="0" y="${y}" width="${progressWidth}" height="${progressBarHeight}" fill="${color}" rx="1"/>`);
                }
            });

            const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${nodeWidth}" height="${nodeHeight}">${svgParts.join('')}</svg>`;
            return 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svg);
        }

        // Custom layout: Master on left, Slave on right, Relay in center
        function applyCustomLayout() {
            if (!cy || cy.elements().length === 0) {
                return;
            }
            
            const containerWidth = cy.width();
            const containerHeight = cy.height();
            
            // Use default dimensions if container not ready
            if (containerWidth === 0 || containerHeight === 0) {
                return;
            }
            
            const leftX = containerWidth * 0.2;      // Master nodes on left
            const centerX = containerWidth * 0.5;   // Relay in center
            const rightX = containerWidth * 0.8;     // Slave nodes on right
            
            // Support both CHI node types (RN/HN/SN) and legacy types (master/slave/relay)
            const masters = cy.nodes('[type="RN"], [type="master"]');
            const slaves = cy.nodes('[type="SN"], [type="slave"]');
            const relays = cy.nodes('[type="HN"], [type="relay"]');
            
            // Layout Master nodes on left, vertically distributed
            if (masters.length > 0) {
                const masterSpacing = Math.min(containerHeight / Math.max(masters.length + 1, 2), 150);
                const totalHeight = (masters.length - 1) * masterSpacing;
                const startY = (containerHeight - totalHeight) / 2;
                masters.forEach((node, index) => {
                    node.position({
                        x: leftX,
                        y: startY + index * masterSpacing
                    });
                });
            }
            
            // Layout Relay node(s) in center
            if (relays.length > 0) {
                relays.forEach((node) => {
                    node.position({
                        x: centerX,
                        y: containerHeight / 2
                    });
                });
            }
            
            // Layout Slave nodes on right, vertically distributed
            if (slaves.length > 0) {
                const slaveSpacing = Math.min(containerHeight / Math.max(slaves.length + 1, 2), 150);
                const totalHeight = (slaves.length - 1) * slaveSpacing;
                const startY = (containerHeight - totalHeight) / 2;
                slaves.forEach((node, index) => {
                    node.position({
                        x: rightX,
                        y: startY + index * slaveSpacing
                    });
                });
            }
        }

        // Initialize Cytoscape
        function initCytoscape() {
            cy = cytoscape({
                container: document.getElementById('cy'),
                elements: [],
                style: [
                    {
                        selector: 'node',
                        style: {
                            'label': 'data(label)',
                            'width': '60px',
                            'height': 'data(height)',
                            'shape': 'round-rectangle',
                            'background-color': '#e8e8e8',
                            'background-image': 'data(progressBg)',
                            'background-width': '100%',
                            'background-height': '100%',
                            'background-fit': 'cover',
                            'background-position-x': '0%',
                            'background-position-y': '100%',
                            'border-width': 2,
                            'border-color': '#888',
                            'text-valign': 'center',
                            'text-halign': 'center',
                            'font-size': '12px',
                            'font-weight': 'bold',
                            'color': '#333',
                            'text-wrap': 'wrap',
                            'text-max-width': '80px'
                        }
                    },
                    {
                        selector: 'node[type="RN"], node[type="master"]',
                        style: {
                            'background-color': '#4a9eff',
                            'border-color': '#0066cc',
                            'color': 'white'
                        }
                    },
                    {
                        selector: 'node[type="SN"], node[type="slave"]',
                        style: {
                            'background-color': '#52c41a',
                            'border-color': '#389e0d',
                            'color': 'white'
                        }
                    },
                    {
                        selector: 'node[type="HN"], node[type="relay"]',
                        style: {
                            'background-color': '#ff7a45',
                            'border-color': '#d4380d',
                            'color': 'white'
                        }
                    },
                    {
                        selector: 'edge',
                        style: {
                            'width': 2,
                            'line-color': '#999',
                            'target-arrow-color': '#999',
                            'target-arrow-shape': 'triangle',
                            'curve-style': 'bezier',
                            'label': 'data(label)',
                            'font-size': '10px',
                            'text-rotation': 'autorotate',
                            'text-margin-y': -10
                        }
                    },
                    {
                        selector: 'edge[label="Req"], edge[label="request"]',
                        style: {
                            'line-color': '#4a9eff',
                            'target-arrow-color': '#4a9eff'
                        }
                    },
                    {
                        selector: 'edge[label="Comp"], edge[label="response"]',
                        style: {
                            'line-color': '#52c41a',
                            'target-arrow-color': '#52c41a'
                        }
                    },
                    {
                        selector: 'edge[label="forward"]',
                        style: {
                            'line-color': '#ff7a45',
                            'target-arrow-color': '#ff7a45'
                        }
                    },
                    {
                        selector: 'edge[label="return"]',
                        style: {
                            'line-color': '#faad14',
                            'target-arrow-color': '#faad14'
                        }
                    }
                ]
            });

            // Register cytoscape-qtip plugin if available
            if (typeof cyqtip === 'function') {
                cyqtip(cytoscape);
            }

            // Add hover tooltip for nodes
            cy.on('mouseover', 'node', function(evt) {
                const node = evt.target;
                const data = node.data();
                let tooltip = `${data.label}\nID: ${data.id}\nType: ${data.type}`;
                
                // Display CHI protocol information
                if (data.payload && data.payload.chiProtocol) {
                    const nodeTypeMap = {'RN': 'Request Node (CHI)', 'HN': 'Home Node (CHI)', 'SN': 'Slave Node (CHI)'};
                    const chiType = data.payload.nodeType || data.type;
                    tooltip += `\nCHI Protocol: ${nodeTypeMap[chiType] || chiType}`;
                }
                
                if (data.queues && data.queues.length > 0) {
                    tooltip += '\n\nQueues:';
                    data.queues.forEach(q => {
                        const cap = q.capacity === -1 ? '∞' : q.capacity;
                        tooltip += `\n${q.name}: ${q.length}/${cap}`;
                    });
                }

                if (data.payload) {
                    tooltip += '\n\nStats:';
                    for (const [key, value] of Object.entries(data.payload)) {
                        // Skip internal CHI protocol fields in tooltip
                        if (key === 'chiProtocol' || key === 'nodeType') continue;
                        if (typeof value === 'number') {
                            tooltip += `\n${key}: ${value.toFixed(2)}`;
                        } else {
                            tooltip += `\n${key}: ${value}`;
                        }
                    }
                }

                node.qtip({
                    content: tooltip,
                    position: {
                        my: 'top center',
                        at: 'bottom center'
                    },
                    style: {
                        classes: 'qtip-bootstrap',
                        tip: {
                            width: 16,
                            height: 8
                        }
                    },
                    show: {
                        event: 'mouseover',
                        ready: true
                    },
                    hide: {
                        event: 'mouseout'
                    }
                }, evt);
            });

            // Add click event for nodes to show packet information
            cy.on('tap', 'node', function(evt) {
                const node = evt.target;
                const data = node.data();
                showPacketModal(data);
            });

            // Add hover tooltip for edges to show pipeline stages
            cy.on('mouseover', 'edge', function(evt) {
                const edge = evt.target;
                const data = edge.data();
                let tooltip = `${data.label}\nSource: ${data.source} → Target: ${data.target}`;
                
                if (data.pipelineStages && data.pipelineStages.length > 0) {
                    tooltip += '\n\nPipeline Stages:';
                    data.pipelineStages.forEach(stage => {
                        tooltip += `\nStage ${stage.stageIndex}: ${stage.packetCount} packet(s)`;
                    });
                    
                    // Indicate potential backpressure if Slot[0] has packets
                    if (data.pipelineStages[0] && data.pipelineStages[0].packetCount > 0) {
                        tooltip += '\n\n⚠ Slot[0] has packets (may indicate backpressure)';
                    }
                } else {
                    tooltip += '\n\nNo pipeline data available';
                }

                edge.qtip({
                    content: tooltip,
                    position: {
                        my: 'top center',
                        at: 'bottom center'
                    },
                    style: {
                        classes: 'qtip-bootstrap',
                        tip: {
                            width: 16,
                            height: 8
                        }
                    },
                    show: {
                        event: 'mouseover',
                        ready: true
                    },
                    hide: {
                        event: 'mouseout'
                    }
                }, evt);
            });

            // Update pipeline state points when view changes (pan, zoom, render)
            cy.on('render', function() {
                if (currentFrame) {
                    drawPipelineStatePoints(currentFrame);
                }
            });
            
            // Recalculate points on pan (translation)
            cy.on('pan', function() {
                if (currentFrame) {
                    drawPipelineStatePoints(currentFrame);
                }
            });
            
            // Recalculate points on zoom
            cy.on('zoom', function() {
                if (currentFrame) {
                    drawPipelineStatePoints(currentFrame);
                }
            });
            
            // Recalculate points on panzoom (combined pan and zoom)
            cy.on('panzoom', function() {
                if (currentFrame) {
                    drawPipelineStatePoints(currentFrame);
                }
            });
        }

        // Format CHI protocol field values for display
        function formatCHIField(field, value) {
            if (value === undefined || value === null || value === '') {
                return 'N/A';
            }
            
            if (field === 'transactionType') {
                const typeMap = {
                    'ReadNoSnp': 'ReadNoSnp',
                    'WriteNoSnp': 'WriteNoSnp',
                    'ReadOnce': 'ReadOnce',
                    'WriteUnique': 'WriteUnique'
                };
                return typeMap[value] || value;
            }
            
            if (field === 'messageType') {
                const typeMap = {
                    'Req': 'Request',
                    'Resp': 'Response',
                    'Data': 'Data',
                    'Comp': 'Completion'
                };
                return typeMap[value] || value;
            }
            
            if (field === 'responseType') {
                const typeMap = {
                    'CompData': 'CompData (Completion with Data)',
                    'CompAck': 'CompAck (Completion Acknowledgment)'
                };
                return typeMap[value] || value;
            }
            
            if (field === 'address') {
                return '0x' + value.toString(16).toUpperCase().padStart(16, '0');
            }
            
            if (field === 'type') {
                return value.charAt(0).toUpperCase() + value.slice(1);
            }
            
            return value;
        }

        // Format packet information for display
        function formatPacketInfo(packet) {
            const fields = [
                { label: 'Packet ID', key: 'id', format: (v) => v },
                { label: 'Type', key: 'type', format: (v) => formatCHIField('type', v) },
                { label: 'Source Node ID', key: 'srcID', format: (v) => v !== undefined ? v : 'N/A' },
                { label: 'Destination Node ID', key: 'dstID', format: (v) => v !== undefined ? v : 'N/A' },
                { label: 'Master ID', key: 'masterID', format: (v) => v !== undefined ? v : 'N/A' },
                { label: 'Request ID', key: 'requestID', format: (v) => v !== undefined ? v : 'N/A' },
                { label: 'Transaction Type', key: 'transactionType', format: (v) => formatCHIField('transactionType', v) },
                { label: 'Message Type', key: 'messageType', format: (v) => formatCHIField('messageType', v) },
                { label: 'Response Type', key: 'responseType', format: (v) => formatCHIField('responseType', v) },
                { label: 'Address', key: 'address', format: (v) => v !== undefined ? formatCHIField('address', v) : 'N/A' },
                { label: 'Data Size (bytes)', key: 'dataSize', format: (v) => v !== undefined ? v : 'N/A' },
                { label: 'Generated At (cycle)', key: 'generatedAt', format: (v) => v !== undefined && v !== 0 ? v : 'N/A' },
                { label: 'Sent At (cycle)', key: 'sentAt', format: (v) => v !== undefined && v !== 0 ? v : 'N/A' },
                { label: 'Received At (cycle)', key: 'receivedAt', format: (v) => v !== undefined && v !== 0 ? v : 'N/A' },
                { label: 'Completed At (cycle)', key: 'completedAt', format: (v) => v !== undefined && v !== 0 ? v : 'N/A' }
            ];
            
            let html = '<table class="packet-table">';
            fields.forEach(field => {
                const value = packet[field.key];
                if (value !== undefined && value !== null && value !== '') {
                    html += `<tr><td class="packet-field-label">${field.label}:</td><td class="packet-field-value">${field.format(value)}</td></tr>`;
                }
            });
            html += '</table>';
            return html;
        }

        // Show packet modal with node information
        function showPacketModal(nodeData) {
            const modal = document.getElementById('packetModal');
            const modalTitle = document.getElementById('modalTitle');
            const modalBody = document.getElementById('modalBody');
            
            modalTitle.textContent = `${nodeData.label || 'Node'} - Packet Information`;
            
            let html = '';
            
            if (!nodeData.queues || nodeData.queues.length === 0) {
                html = '<div class="queue-section empty">No queues found for this node.</div>';
            } else {
                nodeData.queues.forEach(queue => {
                    html += `<div class="queue-section">`;
                    html += `<h3>${queue.name} (${queue.length}/${queue.capacity === -1 ? '∞' : queue.capacity})</h3>`;
                    
                    if (!queue.packets || queue.packets.length === 0) {
                        html += '<div class="empty">This queue is empty.</div>';
                    } else {
                        queue.packets.forEach((packet, index) => {
                            html += `<div class="packet-item">`;
                            html += `<div class="packet-item-header">Packet #${index + 1} (ID: <span class="packet-id">${packet.id}</span>)</div>`;
                            html += `<div class="packet-item-body">`;
                            html += formatPacketInfo(packet);
                            html += `</div></div>`;
                        });
                    }
                    
                    html += `</div>`;
                });
            }
            
            modalBody.innerHTML = html;
            modal.classList.add('show');
        }

        // Close modal
        function closePacketModal() {
            const modal = document.getElementById('packetModal');
            modal.classList.remove('show');
        }

        // Draw pipeline state points on edges using Cytoscape's midpoint API
        function drawPipelineStatePoints(frame) {
            if (!frame || !frame.edges || !cy) {
                return;
            }

            const overlay = document.getElementById('pipelineOverlay');
            if (!overlay) {
                return;
            }

            // Clear existing points
            overlay.innerHTML = '';

            // Get container position for coordinate conversion
            const container = document.getElementById('cy');
            const containerRect = container.getBoundingClientRect();

            frame.edges.forEach(edge => {
                const edgeId = `e${edge.source}-${edge.target}`;
                const cyEdge = cy.getElementById(edgeId);
                
                if (cyEdge.length === 0) {
                    return;
                }

                // Get the first edge element from the collection
                const cyEdgeElement = cyEdge[0];

                // Get data from both frame edge and Cytoscape edge (Cytoscape edge has the latest data)
                const edgeData = cyEdgeElement.data();
                const latency = edgeData.latency || edge.latency || 1;
                const bandwidthLimit = edgeData.bandwidthLimit || edge.bandwidthLimit || 1;
                const pipelineStages = edgeData.pipelineStages || edge.pipelineStages || [];

                // Validate values before drawing
                if (!latency || latency <= 0 || !isFinite(latency)) {
                    return;
                }
                if (!bandwidthLimit || bandwidthLimit <= 0 || !isFinite(bandwidthLimit)) {
                    return;
                }

                // Draw points using Cytoscape's midpoint API
                drawPointsOnEdge(cyEdgeElement, edge, latency, bandwidthLimit, pipelineStages, overlay);
            });

            // Update SVG size to match container
            overlay.setAttribute('width', containerRect.width);
            overlay.setAttribute('height', containerRect.height);
        }

        // Draw pipeline state points on a single edge using Cytoscape's midpoint API
        // Implementation: Use Cytoscape's midpoint() API + linear interpolation
        // This avoids manual Bezier curve calculation and ensures coordinate alignment
        function drawPointsOnEdge(cyEdge, edge, latency, bandwidthLimit, pipelineStages, overlay) {
            const container = document.getElementById('cy');
            if (!container) {
                return;
            }
            const containerRect = container.getBoundingClientRect();

            // Validate input parameters
            if (!latency || latency <= 0 || !isFinite(latency)) {
                return;
            }
            if (!bandwidthLimit || bandwidthLimit <= 0 || !isFinite(bandwidthLimit)) {
                return;
            }

            // Create a mapping of stageIndex to PacketCount
            const stageMap = {};
            if (pipelineStages && Array.isArray(pipelineStages)) {
                pipelineStages.forEach(stage => {
                    if (stage && typeof stage.stageIndex === 'number' && typeof stage.packetCount === 'number') {
                        stageMap[stage.stageIndex] = stage.packetCount;
                    }
                });
            }

            // Get source and target nodes
            const sourceNode = cyEdge.source();
            const targetNode = cyEdge.target();
            
            if (!sourceNode || !targetNode || sourceNode.length === 0 || targetNode.length === 0) {
                console.warn('Edge source or target node not found');
                return;
            }

            // Get source and target endpoint positions using renderedPosition()
            // renderedPosition() returns coordinates relative to the Cytoscape container
            // which matches the SVG overlay coordinate system
            let sourcePos, targetPos;
            
            try {
                // Use renderedPosition() which already accounts for zoom and pan
                // and returns coordinates relative to the container
                sourcePos = sourceNode.renderedPosition();
                targetPos = targetNode.renderedPosition();
                
                // Validate positions
                if (!sourcePos || !targetPos ||
                    !isFinite(sourcePos.x) || !isFinite(sourcePos.y) ||
                    !isFinite(targetPos.x) || !isFinite(targetPos.y)) {
                    throw new Error('renderedPosition() returned invalid values');
                }
            } catch (e) {
                console.warn('Failed to get edge positions using renderedPosition():', e);
                // Fallback: try position() and convert manually
                try {
                    const srcModelPos = sourceNode.position();
                    const tgtModelPos = targetNode.position();
                    const zoom = cy.zoom();
                    const pan = cy.pan();
                    
                    if (isFinite(srcModelPos.x) && isFinite(srcModelPos.y) &&
                        isFinite(tgtModelPos.x) && isFinite(tgtModelPos.y)) {
                        sourcePos = {
                            x: srcModelPos.x * zoom + pan.x,
                            y: srcModelPos.y * zoom + pan.y
                        };
                        targetPos = {
                            x: tgtModelPos.x * zoom + pan.x,
                            y: tgtModelPos.y * zoom + pan.y
                        };
                    } else {
                        throw new Error('position() also returned invalid values');
                    }
                } catch (e2) {
                    console.warn('All methods failed to get edge positions:', e2);
                    return;
                }
            }

            // Get midpoint using Cytoscape's midpoint() API
            // IMPORTANT: midpoint() returns MODEL coordinates, not rendered coordinates
            // We need to convert them to rendered coordinates using zoom and pan
            let midPoint;
            try {
                // Get midpoint in model coordinates
                const midPointModel = cyEdge.midpoint();
                
                // Validate model midpoint
                if (midPointModel && isFinite(midPointModel.x) && isFinite(midPointModel.y)) {
                    // Convert model coordinates to rendered coordinates
                    const zoom = cy.zoom();
                    const pan = cy.pan();
                    midPoint = {
                        x: midPointModel.x * zoom + pan.x,
                        y: midPointModel.y * zoom + pan.y
                    };
                } else {
                    // Fallback: calculate from rendered source and target positions
                    midPoint = {
                        x: (sourcePos.x + targetPos.x) / 2,
                        y: (sourcePos.y + targetPos.y) / 2
                    };
                }
            } catch (e) {
                // Fallback: calculate midpoint manually from rendered positions
                midPoint = {
                    x: (sourcePos.x + targetPos.x) / 2,
                    y: (sourcePos.y + targetPos.y) / 2
                };
            }
            
            // Final validation
            if (!isFinite(midPoint.x) || !isFinite(midPoint.y)) {
                console.warn('Failed to get valid midpoint');
                return;
            }

            // Draw points for each stage using linear interpolation
            // Interpolate between source, midpoint, and target to approximate curve position
            for (let stageIdx = 0; stageIdx < latency; stageIdx++) {
                // Calculate position ratio along the edge
                // Slot[0] (first stage, ready to arrive) should be near target
                // Slot[latency-1] (last stage, entry point) near source
                let ratio;
                if (latency === 1) {
                    ratio = 0.5; // Single stage at midpoint
                } else {
                    // Distribute points from 40% to 60% of the edge to avoid node overlap
                    // Map stageIdx from [0, latency-1] to [0.6, 0.4] (reversed)
                    ratio = 0.6 - (stageIdx / (latency - 1)) * 0.2;
                }

                // Linear interpolation between source, midpoint, and target
                // This approximates the curve position for better alignment
                let pointX, pointY;
                if (ratio <= 0.5) {
                    // Between source and midpoint
                    const t = ratio * 2; // Map [0, 0.5] to [0, 1]
                    pointX = sourcePos.x + (midPoint.x - sourcePos.x) * t;
                    pointY = sourcePos.y + (midPoint.y - sourcePos.y) * t;
                } else {
                    // Between midpoint and target
                    const t = (ratio - 0.5) * 2; // Map [0.5, 1] to [0, 1]
                    pointX = midPoint.x + (targetPos.x - midPoint.x) * t;
                    pointY = midPoint.y + (targetPos.y - midPoint.y) * t;
                }

                // Calculate perpendicular direction at the interpolated point
                // For linear interpolation, use the local direction vector
                // This is the direction from the previous point to the next point along the edge
                let dirX, dirY;
                if (ratio <= 0.5) {
                    // Direction from source to midpoint
                    dirX = midPoint.x - sourcePos.x;
                    dirY = midPoint.y - sourcePos.y;
                } else {
                    // Direction from midpoint to target
                    dirX = targetPos.x - midPoint.x;
                    dirY = targetPos.y - midPoint.y;
                }
                
                const length = Math.sqrt(dirX * dirX + dirY * dirY);
                let perpDir = { x: 0, y: 1 }; // Default vertical
                if (length > 0) {
                    // Perpendicular vector (rotated 90 degrees clockwise)
                    perpDir = {
                        x: dirY / length,
                        y: -dirX / length
                    };
                }

                const packetCount = stageMap[stageIdx] || 0;
                const pointSpacing = 4;
                const totalWidth = (bandwidthLimit - 1) * pointSpacing;
                const startOffset = -totalWidth / 2;

                // Validate interpolated point position
                if (!isFinite(pointX) || !isFinite(pointY)) {
                    console.warn(`Invalid point position for stage ${stageIdx}:`, { pointX, pointY });
                    continue;
                }

                // Draw points for this stage
                for (let i = 0; i < bandwidthLimit; i++) {
                    const offsetX = startOffset + i * pointSpacing;
                    const finalX = pointX + perpDir.x * offsetX;
                    const finalY = pointY + perpDir.y * offsetX;

                    // Validate final coordinates before drawing
                    if (!isFinite(finalX) || !isFinite(finalY)) {
                        console.warn(`Invalid final coordinates for stage ${stageIdx}, point ${i}:`, { finalX, finalY });
                        continue;
                    }

                    const isFilled = i < packetCount;
                    const color = isFilled ? '#ff4d4f' : '#999';
                    const radius = 3;

                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('cx', finalX);
                    circle.setAttribute('cy', finalY);
                    circle.setAttribute('r', radius);
                    circle.setAttribute('fill', color);
                    circle.setAttribute('stroke', '#fff');
                    circle.setAttribute('stroke-width', '0.5');
                    overlay.appendChild(circle);
                }
            }
        }

        // Fetch frame data from API
        async function fetchFrame() {
            try {
                const response = await fetch('/api/frame');
                if (!response.ok) {
                    if (response.status === 404) {
                        return null; // No frame available yet
                    }
                    throw new Error(`HTTP ${response.status}`);
                }
                const frame = await response.json();
                return frame;
            } catch (error) {
                console.error('Error fetching frame:', error);
                showError('Failed to fetch simulation data: ' + error.message);
                return null;
            }
        }

        // Update visualization with frame data
        function updateVisualization(frame) {
            if (!frame || !frame.nodes || !frame.edges) {
                return;
            }

            currentFrame = frame;

            // Check for config change using configHash from frame
            const configHash = frame.configHash || null;
            let shouldReinitialize = false;

            if (expectingReset && frame.cycle === 0) {
                // This is the reset frame we were waiting for
                shouldReinitialize = true;
                expectingReset = false;
                console.log('[DEBUG] Received reset frame (cycle 0), reinitializing topology');
            } else if (configHash && lastConfigHash !== null && configHash !== lastConfigHash) {
                // Config hash changed, network structure has changed
                shouldReinitialize = true;
                console.log('[DEBUG] Config hash changed:', lastConfigHash, '->', configHash, ', reinitializing topology');
            } else if (lastConfigHash === null && configHash) {
                // First frame with config hash, initialize it
                lastConfigHash = configHash;
            }

            if (shouldReinitialize) {
                cy.elements().remove();
                topologyInitialized = false;
                // Update lastConfigHash if configHash is available
                if (configHash) {
                    lastConfigHash = configHash;
                }
            }

            // Update status info
            document.getElementById('currentCycle').textContent = frame.cycle || 0;
            document.getElementById('inFlightCount').textContent = frame.inFlightCount || 0;
            
            const statusEl = document.getElementById('simStatus');
            if (frame.cycle >= (frame.totalCycles || 1000)) {
                statusEl.innerHTML = 'Status: <strong style="color: #52c41a;">Completed</strong>';
            } else {
                statusEl.innerHTML = 'Status: <strong style="color: #1890ff;">Running</strong>';
            }

            // Update button states based on current pause status
            updateButtonStates();

            // Initialize topology on first frame or after config change
            if (!topologyInitialized) {
                const elements = [];

                // Add nodes
                frame.nodes.forEach(node => {
                    const queues = node.queues || [];
                    const nodeWidth = 60;
                    const baseHeight = 60;
                    const progressBarHeight = queues.length > 0 ? queues.length * 3 + (queues.length - 1) * 1 + 4 : 0;
                    const nodeHeight = baseHeight + progressBarHeight;
                    
                    const progressBg = createProgressBarsSVG(queues, nodeWidth, nodeHeight);
                    
                    const nodeData = {
                        group: 'nodes',
                        data: {
                            id: String(node.id),
                            label: node.label || `Node ${node.id}`,
                            type: node.type,
                            queues: queues,
                            payload: node.payload || {},
                            height: nodeHeight,
                            progressBg: progressBg
                        }
                    };
                    elements.push(nodeData);
                });

                // Add edges
                frame.edges.forEach(edge => {
                    const edgeLabel = `${edge.label} (${edge.latency}cy)`;
                    const pipelineStages = edge.pipelineStages || [];
                    elements.push({
                        group: 'edges',
                        data: {
                            id: `e${edge.source}-${edge.target}`,
                            source: String(edge.source),
                            target: String(edge.target),
                            label: edgeLabel,
                            latency: edge.latency,
                            pipelineStages: pipelineStages,
                            bandwidthLimit: edge.bandwidthLimit
                        }
                    });
                });

                // Add all elements
                cy.add(elements);
                
                // Apply custom layout after elements are added
                // Use setTimeout to ensure Cytoscape has processed the elements
                setTimeout(() => {
                    applyCustomLayout();
                }, 50);
                
                topologyInitialized = true;
                // Update current config name after topology is initialized
                const newConfigName = getConfigFromForm();
                currentConfigName = newConfigName;
                // Update lastConfigHash if we have it from frame
                if (frame.configHash) {
                    lastConfigHash = frame.configHash;
                }
            }

            // Update existing nodes with new data (without re-layout)
            frame.nodes.forEach(node => {
                const nodeId = String(node.id);
                const cyNode = cy.getElementById(nodeId);
                
                if (cyNode.length > 0) {
                    const queues = node.queues || [];
                    const nodeWidth = 60;
                    const baseHeight = 60;
                    const progressBarHeight = queues.length > 0 ? queues.length * 3 + (queues.length - 1) * 1 + 4 : 0;
                    const nodeHeight = baseHeight + progressBarHeight;
                    
                    const progressBg = createProgressBarsSVG(queues, nodeWidth, nodeHeight);
                    
                    // Update node data
                    let label = node.label || `Node ${node.id}`;
                    if (queues.length > 0) {
                        const queueInfo = queues.map(q => {
                            const cap = q.capacity === -1 ? '∞' : q.capacity;
                            return `${q.name}:${q.length}/${cap}`;
                        }).join(' ');
                        label += `\n${queueInfo}`;
                    }

                    cyNode.data({
                        label: label,
                        queues: queues,
                        payload: node.payload || {},
                        height: nodeHeight,
                        progressBg: progressBg
                    });
                }
            });

            // Update existing edges with pipeline stages
            frame.edges.forEach(edge => {
                const edgeId = `e${edge.source}-${edge.target}`;
                const cyEdge = cy.getElementById(edgeId);
                
                if (cyEdge.length > 0) {
                    const pipelineStages = edge.pipelineStages || [];
                    let edgeLabel = `${edge.label} (${edge.latency}cy)`;
                    
                    cyEdge.data({
                        label: edgeLabel,
                        pipelineStages: pipelineStages,
                        bandwidthLimit: edge.bandwidthLimit
                    });
                    
                    // Update edge style based on backpressure (Slot[0] has packets but can't advance)
                    if (pipelineStages.length > 0 && pipelineStages[0].packetCount > 0) {
                        // Check if this indicates backpressure (would need receiver state, simplified here)
                        cyEdge.style('line-color', '#ff4d4f'); // Red for potential backpressure
                        cyEdge.style('width', 3);
                    } else {
                        cyEdge.style('line-color', '#91d5ff'); // Blue for normal
                        cyEdge.style('width', 2);
                    }
                }
            });

            // Draw pipeline state points
            drawPipelineStatePoints(frame);

            // Update statistics
            updateStatistics(frame.stats);
        }

        // Update statistics panel
        function updateStatistics(stats) {
            const panel = document.getElementById('statsPanel');
            if (!stats || !stats.Global) {
                panel.innerHTML = '<div class="stats-item"><div style="text-align: center; color: #999;">No data available</div></div>';
                return;
            }

            let html = '';

            // Global stats
            html += '<div class="stats-item">';
            html += '<h4>Global Statistics</h4>';
            html += '<div class="stats-grid">';
            html += `<div class="stats-value">Total Requests: <strong>${stats.Global.TotalRequests}</strong></div>`;
            html += `<div class="stats-value">Completed: <strong>${stats.Global.Completed}</strong></div>`;
            html += `<div class="stats-value">Completion Rate: <strong>${stats.Global.CompletionRate.toFixed(2)}%</strong></div>`;
            html += `<div class="stats-value">Avg Delay: <strong>${stats.Global.AvgEndToEndDelay.toFixed(2)} cy</strong></div>`;
            html += `<div class="stats-value">Max Delay: <strong>${stats.Global.MaxDelay} cy</strong></div>`;
            html += `<div class="stats-value">Min Delay: <strong>${stats.Global.MinDelay} cy</strong></div>`;
            html += '</div>';
            html += '</div>';

            // Master stats
            if (stats.PerMaster && stats.PerMaster.length > 0) {
                html += '<div class="stats-item">';
                html += '<h4>Master Statistics</h4>';
                stats.PerMaster.forEach((m, idx) => {
                    if (m) {
                        html += `<div style="margin-top: 6px; padding-top: 6px; border-top: 1px solid #eee;">`;
                        html += `<strong>Master ${idx}</strong><br>`;
                        html += `Completed: ${m.CompletedRequests}, `;
                        html += `Avg Delay: ${m.AvgDelay.toFixed(2)} cy, `;
                        html += `Max: ${m.MaxDelay} cy, Min: ${m.MinDelay} cy`;
                        html += '</div>';
                    }
                });
                html += '</div>';
            }

            // Slave stats
            if (stats.PerSlave && stats.PerSlave.length > 0) {
                html += '<div class="stats-item">';
                html += '<h4>Slave Statistics</h4>';
                stats.PerSlave.forEach((s, idx) => {
                    if (s) {
                        html += `<div style="margin-top: 6px; padding-top: 6px; border-top: 1px solid #eee;">`;
                        html += `<strong>Slave ${idx}</strong><br>`;
                        html += `Processed: ${s.TotalProcessed}, `;
                        html += `Max Queue: ${s.MaxQueueLength}, `;
                        html += `Avg Queue: ${s.AvgQueueLength.toFixed(2)}`;
                        html += '</div>';
                    }
                });
                html += '</div>';
            }

            panel.innerHTML = html;
        }

        // Send control command (prefer WebSocket, fallback to HTTP)
        async function sendControl(type, configName, totalCycles) {
            const body = { type: type };
            if (configName) {
                body.configName = configName;
            }
            if (totalCycles !== undefined && totalCycles !== null) {
                body.totalCycles = totalCycles;
            }

            // Try WebSocket first if connected
            if (ws && ws.readyState === WebSocket.OPEN) {
                try {
                    ws.send(JSON.stringify(body));
                    hideError();
                    return true;
                } catch (error) {
                    console.warn('[WebSocket] Failed to send via WebSocket, falling back to HTTP:', error);
                }
            }

            // Fallback to HTTP
            try {
                const response = await fetch('/api/control', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(body)
                });

                if (!response.ok) {
                    const text = await response.text();
                    throw new Error(text || `HTTP ${response.status}`);
                }

                hideError();
                return true;
            } catch (error) {
                console.error('Error sending control:', error);
                showError('Failed to send command: ' + error.message);
                return false;
            }
        }

        // Load available network configurations
        async function loadConfigurations() {
            try {
                const response = await fetch('/api/configs');
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                const configs = await response.json();
                
                const select = document.getElementById('networkConfig');
                select.innerHTML = '';
                
                if (configs.length === 0) {
                    select.innerHTML = '<option value="">No configurations available</option>';
                    return;
                }
                
                configs.forEach((cfg, index) => {
                    const option = document.createElement('option');
                    option.value = cfg.name;
                    option.textContent = cfg.description;
                    if (index === 0) {
                        option.selected = true;
                    }
                    select.appendChild(option);
                });
            } catch (error) {
                console.error('Error loading configurations:', error);
                const select = document.getElementById('networkConfig');
                select.innerHTML = '<option value="">Error loading configurations</option>';
                showError('Failed to load network configurations: ' + error.message);
            }
        }

        // Get selected configuration name from form
        function getConfigFromForm() {
            const select = document.getElementById('networkConfig');
            return select.value;
        }

        // Validate configuration
        function validateConfig(configName) {
            if (!configName) {
                return 'Please select a network configuration';
            }
            const totalCycles = parseInt(document.getElementById('totalCycles').value);
            if (isNaN(totalCycles) || totalCycles <= 0) {
                return 'TotalCycles must be a positive number';
            }
            return null;
        }

        // Show error message
        function showError(message) {
            const errorEl = document.getElementById('errorMessage');
            errorEl.textContent = message;
            errorEl.classList.add('show');
        }

        // Hide error message
        function hideError() {
            const errorEl = document.getElementById('errorMessage');
            errorEl.classList.remove('show');
        }

        // Fetch frame immediately (used after step commands)
        async function fetchFrameImmediate() {
            const frame = await fetchFrame();
            if (frame) {
                updateVisualization(frame);
            }
            return frame;
        }

        // Connect to WebSocket for real-time updates
        function connectWebSocket() {
            // Close existing connection if any
            if (ws) {
                ws.close();
                ws = null;
            }

            // Clear any pending reconnect
            if (wsReconnectTimeout) {
                clearTimeout(wsReconnectTimeout);
                wsReconnectTimeout = null;
            }

            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws`;
            
            try {
                ws = new WebSocket(wsUrl);

                ws.onopen = () => {
                    console.log('[WebSocket] Connected');
                    hideError();
                };

                ws.onmessage = (event) => {
                    try {
                        const frame = JSON.parse(event.data);
                        if (frame) {
                            updateVisualization(frame);
                        }
                    } catch (error) {
                        console.error('[WebSocket] Error parsing frame:', error);
                    }
                };

                ws.onerror = (error) => {
                    console.error('[WebSocket] Error:', error);
                    showError('WebSocket connection error. Please refresh the page to reconnect.');
                };

                ws.onclose = () => {
                    console.log('[WebSocket] Disconnected');
                    ws = null;
                    // Attempt to reconnect after 2 seconds
                    wsReconnectTimeout = setTimeout(() => {
                        console.log('[WebSocket] Attempting to reconnect...');
                        connectWebSocket();
                    }, 2000);
                };
            } catch (error) {
                console.error('[WebSocket] Failed to connect:', error);
                showError('WebSocket connection failed. Please refresh the page to reconnect.');
            }
        }

        // Disconnect WebSocket
        function disconnectWebSocket() {
            if (wsReconnectTimeout) {
                clearTimeout(wsReconnectTimeout);
                wsReconnectTimeout = null;
            }
            if (ws) {
                ws.close();
                ws = null;
            }
        }

        // Update button states based on pause status
        function updateButtonStates() {
            const btnPause = document.getElementById('btnPause');
            const btnResume = document.getElementById('btnResume');
            const btnStep = document.getElementById('btnStep');
            
            if (btnPause) {
                btnPause.disabled = isPaused; // Disable when paused
            }
            if (btnResume) {
                btnResume.disabled = !isPaused; // Disable when running
            }
            if (btnStep) {
                // Disable step button if not paused or if a step is being processed
                btnStep.disabled = !isPaused || isStepProcessing;
            }
        }

        // Event listeners
        document.getElementById('btnPause').addEventListener('click', async () => {
            const success = await sendControl('pause');
            if (success) {
                isPaused = true;
                updateButtonStates();
            }
        });

        document.getElementById('btnResume').addEventListener('click', async () => {
            const success = await sendControl('resume');
            if (success) {
                isPaused = false;
                updateButtonStates();
            }
        });

        document.getElementById('btnStep').addEventListener('click', async () => {
            if (!isPaused || isStepProcessing) {
                return; // Step button should only work when paused and not processing
            }
            
            // Set processing flag to prevent duplicate clicks
            isStepProcessing = true;
            updateButtonStates();
            
            try {
                const success = await sendControl('step');
                if (success) {
                    // Step command sent, immediately fetch frame to get updated state
                    // Wait a short time for simulator to process the step
                    await new Promise(resolve => setTimeout(resolve, 100));
                    
                    // Try to fetch frame multiple times with short delays to ensure we get the update
                    let frame = null;
                    for (let i = 0; i < 5; i++) {
                        frame = await fetchFrameImmediate();
                        if (frame) {
                            break;
                        }
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }
                }
            } finally {
                // Reset processing flag after a delay to allow for visual feedback
                setTimeout(() => {
                    isStepProcessing = false;
                    updateButtonStates();
                }, 200);
            }
        });

        document.getElementById('btnReset').addEventListener('click', async () => {
            const configName = getConfigFromForm();
            const error = validateConfig(configName);
            if (error) {
                showError(error);
                return;
            }
            const totalCycles = parseInt(document.getElementById('totalCycles').value);
            const success = await sendControl('reset', configName, totalCycles);
            if (success) {
                isPaused = true; // Reset pauses at cycle 0
                updateButtonStates();
                // Clear visualization and reset topology
                cy.elements().remove();
                topologyInitialized = false;
                // Update current config name to track the new configuration
                currentConfigName = configName;
                // Set flag to wait for reset frame (cycle 0)
                expectingReset = true;
                console.log('[DEBUG] Reset clicked, waiting for cycle 0 frame');
                document.getElementById('currentCycle').textContent = '-';
                document.getElementById('inFlightCount').textContent = '-';
                document.getElementById('simStatus').innerHTML = 'Status: <strong>Resetting...</strong>';
            }
        });

        // Initialize
        loadConfigurations();
        initCytoscape();
        updateButtonStates(); // Set initial button states (paused at cycle 0)
        connectWebSocket(); // Connect to WebSocket for real-time updates

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            disconnectWebSocket();
        });

        // Modal close event listeners (initialize after DOM is ready)
        document.getElementById('modalClose').addEventListener('click', closePacketModal);
        document.getElementById('packetModal').addEventListener('click', function(e) {
            if (e.target === this) {
                closePacketModal();
            }
        });

        // Reapply layout on window resize
        let resizeTimeout;
        window.addEventListener('resize', () => {
            if (topologyInitialized) {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    applyCustomLayout();
                }, 250);
            }
        });

        // Initial frame fetch
        fetchFrame().then(frame => {
            if (frame) {
                updateVisualization(frame);
            }
        });
    </script>
</body>
</html>

