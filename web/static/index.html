<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flow Control Simulator - Visualization</title>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/qtip2@3.0.3/dist/jquery.qtip.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/qtip2@3.0.3/dist/jquery.qtip.min.css">
    <script src="https://cdn.jsdelivr.net/npm/cytoscape@3.27.0/dist/cytoscape.min.js"></script>
    <script src="https://unpkg.com/cytoscape-qtip@2.8.0/cytoscape-qtip.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        .control-panel {
            width: 350px;
            background: #f5f5f5;
            border-right: 1px solid #ddd;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        .control-section {
            padding: 15px;
            border-bottom: 1px solid #ddd;
        }

        .control-section h3 {
            margin-bottom: 10px;
            color: #333;
            font-size: 14px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .control-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        button {
            padding: 8px 16px;
            border: 1px solid #ccc;
            background: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }

        button:hover:not(:disabled) {
            background: #f0f0f0;
            border-color: #999;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        button.primary {
            background: #007bff;
            color: white;
            border-color: #007bff;
        }

        button.primary:hover:not(:disabled) {
            background: #0056b3;
        }

        button.danger {
            background: #dc3545;
            color: white;
            border-color: #dc3545;
        }

        button.danger:hover:not(:disabled) {
            background: #c82333;
        }

        .status-info {
            font-size: 12px;
            color: #666;
            margin-top: 8px;
        }

        .status-info strong {
            color: #333;
        }

        .config-form {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .form-group label {
            font-size: 12px;
            color: #666;
            font-weight: 500;
        }

        .form-group input {
            padding: 6px 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 13px;
        }

        .form-group input:focus {
            outline: none;
            border-color: #007bff;
        }

        .form-row {
            display: flex;
            gap: 10px;
        }

        .form-row .form-group {
            flex: 1;
        }

        .stats-panel {
            max-height: 400px;
            overflow-y: auto;
        }

        .stats-item {
            padding: 8px;
            background: white;
            border-radius: 4px;
            margin-bottom: 8px;
            font-size: 12px;
        }

        .stats-item h4 {
            margin-bottom: 6px;
            color: #333;
            font-size: 13px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            margin-top: 6px;
        }

        .stats-value {
            color: #666;
        }

        .stats-value strong {
            color: #333;
        }

        .visualization-area {
            flex: 1;
            position: relative;
            background: #fff;
        }

        #cy {
            width: 100%;
            height: 100%;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 20px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            z-index: 1000;
        }

        .error-message {
            padding: 10px;
            background: #fee;
            border: 1px solid #fcc;
            border-radius: 4px;
            color: #c33;
            font-size: 12px;
            margin-top: 10px;
            display: none;
        }

        .error-message.show {
            display: block;
        }

        .queue-info {
            font-size: 11px;
            color: #666;
            margin-top: 4px;
        }

        /* Modal styles */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 10000;
            justify-content: center;
            align-items: center;
        }

        .modal-overlay.show {
            display: flex;
        }

        .modal-content {
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            max-width: 800px;
            max-height: 90vh;
            width: 90%;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .modal-header {
            padding: 20px;
            border-bottom: 1px solid #ddd;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #f5f5f5;
        }

        .modal-header h2 {
            margin: 0;
            font-size: 18px;
            color: #333;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #666;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
        }

        .modal-close:hover {
            background: #e0e0e0;
            color: #333;
        }

        .modal-body {
            padding: 20px;
            overflow-y: auto;
            flex: 1;
        }

        .queue-section {
            margin-bottom: 30px;
        }

        .queue-section h3 {
            font-size: 16px;
            color: #333;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 2px solid #007bff;
        }

        .queue-section.empty {
            color: #999;
            font-style: italic;
            padding: 20px;
            text-align: center;
        }

        .packet-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
            font-size: 13px;
        }

        .packet-table th {
            background: #f5f5f5;
            padding: 10px;
            text-align: left;
            border-bottom: 2px solid #ddd;
            font-weight: 600;
            color: #333;
        }

        .packet-table td {
            padding: 10px;
            border-bottom: 1px solid #eee;
        }

        .packet-table tr:hover {
            background: #f9f9f9;
        }

        .packet-id {
            font-weight: 600;
            color: #007bff;
        }

        .packet-field-label {
            font-weight: 500;
            color: #666;
            width: 150px;
        }

        .packet-field-value {
            color: #333;
        }

        /* Sequence diagram styles */
        .sequence-diagram-container {
            width: 100%;
            height: 600px;
            overflow: auto;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: #fff;
            padding: 20px;
        }

        .sequence-diagram-container .mermaid {
            text-align: center;
        }

        .sequence-diagram-loading {
            text-align: center;
            padding: 40px;
            color: #999;
        }

        .sequence-diagram-error {
            padding: 20px;
            background: #fee;
            border: 1px solid #fcc;
            border-radius: 4px;
            color: #c33;
        }

        .packet-item {
            margin-bottom: 20px;
            border: 1px solid #ddd;
            border-radius: 4px;
            overflow: hidden;
        }

        .packet-item-header {
            background: #f5f5f5;
            padding: 10px 15px;
            font-weight: 600;
            color: #333;
            border-bottom: 1px solid #ddd;
        }

        .packet-item-body {
            padding: 15px;
        }

        @media (max-width: 768px) {
            body {
                flex-direction: column;
            }

            .control-panel {
                width: 100%;
                max-height: 40vh;
            }
        }
    </style>
</head>
<body>
    <div class="control-panel">
        <div class="control-section">
            <h3>Simulation Control</h3>
            <div class="control-buttons">
                <button id="btnPause" class="primary">Pause</button>
                <button id="btnResume" class="primary">Resume</button>
                <button id="btnStep" class="primary">Step</button>
                <button id="btnReset" class="danger">Reset</button>
            </div>
            <div class="status-info">
                <div>Cycle: <strong id="currentCycle">-</strong></div>
                <div>In-Flight: <strong id="inFlightCount">-</strong></div>
                <div id="simStatus">Status: <strong>Waiting</strong></div>
            </div>
            <div id="errorMessage" class="error-message"></div>
        </div>

        <div class="control-section">
            <h3>Configuration</h3>
            <div class="config-form">
                <div class="form-group">
                    <label>Network Configuration</label>
                    <select id="networkConfig" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                        <option value="">Loading configurations...</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Total Cycles</label>
                    <input type="number" id="totalCycles" min="1" value="1000">
                </div>
            </div>
            <div class="status-info" style="margin-top: 10px; font-size: 11px; color: #999;">
                Select a predefined network configuration. Changes take effect after Reset.
            </div>
        </div>

        <div class="control-section">
            <h3>Statistics</h3>
            <div class="stats-panel" id="statsPanel">
                <div class="stats-item">
                    <div style="text-align: center; color: #999;">No data available</div>
                </div>
            </div>
        </div>

        <div class="control-section">
            <h3>Transaction Timeline</h3>
            <div class="form-group">
                <label>Transaction ID</label>
                <input type="number" id="transactionID" min="1" placeholder="Enter transaction ID" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
            </div>
            <button id="btnLoadTimeline" class="primary" style="width: 100%; margin-top: 8px;">Load Timeline</button>
            <div id="timelineError" class="error-message" style="margin-top: 8px;"></div>
        </div>
    </div>

    <div class="visualization-area">
        <div id="cy"></div>
        <svg id="pipelineOverlay" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10;"></svg>
        <div id="loading" class="loading" style="display: none;">
            <div>Loading simulation data...</div>
        </div>
    </div>

    <!-- Modal for displaying packet information -->
    <div id="packetModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modalTitle">Node Packet Information</h2>
                <button class="modal-close" id="modalClose">&times;</button>
            </div>
            <div class="modal-body" id="modalBody">
                <!-- Content will be populated by JavaScript -->
            </div>
        </div>
    </div>

    <!-- Modal for displaying sequence diagram -->
    <div id="sequenceDiagramModal" class="modal-overlay">
        <div class="modal-content" style="max-width: 1200px;">
            <div class="modal-header">
                <h2 id="sequenceDiagramTitle">Transaction Timeline</h2>
                <button class="modal-close" id="sequenceDiagramClose">&times;</button>
            </div>
            <div class="modal-body">
                <div id="sequenceDiagramContainer" class="sequence-diagram-container">
                    <div class="sequence-diagram-loading">Loading sequence diagram...</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let cy;
        let ws = null; // WebSocket connection
        let wsReconnectTimeout = null;
        let isPaused = true; // Web mode starts paused at cycle 0
        let currentFrame = null;
        let topologyInitialized = false;
        let currentConfigName = null; // Track current network configuration name
        let lastConfigHash = null; // Track last config hash from frame to detect config changes
        let expectingReset = false; // Track if we're waiting for a reset frame (cycle 0)
        let isStepProcessing = false; // Track if a step command is being processed

        // Calculate load percentage for a queue
        function calculateQueueLoad(queue) {
            if (!queue || queue.capacity === -1 || queue.capacity === 0) {
                return 0; // Unlimited capacity or invalid capacity
            }
            const load = Math.min(100, Math.max(0, (queue.length / queue.capacity) * 100));
            return load;
        }

        // Get color for load percentage
        function getLoadColor(percentage) {
            if (percentage < 50) {
                return '#52c41a'; // Green for low load
            } else if (percentage < 80) {
                return '#faad14'; // Yellow for medium load
            } else {
                return '#ff4d4f'; // Red for high load
            }
        }

        // Create progress bar SVG for multiple queues
        function createProgressBarsSVG(queues, nodeWidth, nodeHeight) {
            if (!queues || queues.length === 0) {
                return 'none';
            }

            const progressBarHeight = 3;
            const progressBarSpacing = 1;
            const totalProgressHeight = queues.length * progressBarHeight + (queues.length - 1) * progressBarSpacing;
            const padding = 2;
            const startY = nodeHeight - totalProgressHeight - padding;

            let svgParts = [];
            
            // Draw transparent background for the entire node (so the original background color shows through)
            svgParts.push(`<rect x="0" y="0" width="${nodeWidth}" height="${nodeHeight}" fill="transparent"/>`);
            
            queues.forEach((queue, index) => {
                const load = calculateQueueLoad(queue);
                const y = startY + index * (progressBarHeight + progressBarSpacing);
                const progressWidth = (load / 100) * nodeWidth;
                const color = getLoadColor(load);

                // Background bar (gray, semi-transparent)
                svgParts.push(`<rect x="0" y="${y}" width="${nodeWidth}" height="${progressBarHeight}" fill="#e0e0e0" opacity="0.6" rx="1"/>`);
                
                // Progress bar (colored)
                if (progressWidth > 0) {
                    svgParts.push(`<rect x="0" y="${y}" width="${progressWidth}" height="${progressBarHeight}" fill="${color}" rx="1"/>`);
                }
            });

            const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${nodeWidth}" height="${nodeHeight}">${svgParts.join('')}</svg>`;
            return 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svg);
        }

        // Custom layout: Master on left, Slave on right, Relay in center
        function applyCustomLayout() {
            if (!cy || cy.elements().length === 0) {
                return;
            }
            
            const containerWidth = cy.width();
            const containerHeight = cy.height();
            
            // Use default dimensions if container not ready
            if (containerWidth === 0 || containerHeight === 0) {
                return;
            }
            
            const leftX = containerWidth * 0.2;      // Master nodes on left
            const centerX = containerWidth * 0.5;   // Relay in center
            const rightX = containerWidth * 0.8;     // Slave nodes on right
            
            // Support both CHI node types (RN/HN/SN) and legacy types (master/slave/relay)
            const masters = cy.nodes('[type="RN"], [type="master"]');
            const slaves = cy.nodes('[type="SN"], [type="slave"]');
            const relays = cy.nodes('[type="HN"], [type="relay"]');
            
            // Layout Master nodes on left, vertically distributed
            if (masters.length > 0) {
                const masterSpacing = Math.min(containerHeight / Math.max(masters.length + 1, 2), 150);
                const totalHeight = (masters.length - 1) * masterSpacing;
                const startY = (containerHeight - totalHeight) / 2;
                masters.forEach((node, index) => {
                    node.position({
                        x: leftX,
                        y: startY + index * masterSpacing
                    });
                });
            }
            
            // Layout Relay node(s) in center
            if (relays.length > 0) {
                relays.forEach((node) => {
                    node.position({
                        x: centerX,
                        y: containerHeight / 2
                    });
                });
            }
            
            // Layout Slave nodes on right, vertically distributed
            if (slaves.length > 0) {
                const slaveSpacing = Math.min(containerHeight / Math.max(slaves.length + 1, 2), 150);
                const totalHeight = (slaves.length - 1) * slaveSpacing;
                const startY = (containerHeight - totalHeight) / 2;
                slaves.forEach((node, index) => {
                    node.position({
                        x: rightX,
                        y: startY + index * slaveSpacing
                    });
                });
            }
        }

        // Initialize Cytoscape
        function initCytoscape() {
            cy = cytoscape({
                container: document.getElementById('cy'),
                elements: [],
                style: [
                    {
                        selector: 'node',
                        style: {
                            'label': 'data(label)',
                            'width': '60px',
                            'height': 'data(height)',
                            'shape': 'round-rectangle',
                            'background-color': '#e8e8e8',
                            'background-image': 'data(progressBg)',
                            'background-width': '100%',
                            'background-height': '100%',
                            'background-fit': 'cover',
                            'background-position-x': '0%',
                            'background-position-y': '100%',
                            'border-width': 2,
                            'border-color': '#888',
                            'text-valign': 'center',
                            'text-halign': 'center',
                            'font-size': '12px',
                            'font-weight': 'bold',
                            'color': '#333',
                            'text-wrap': 'wrap',
                            'text-max-width': '80px'
                        }
                    },
                    {
                        selector: 'node[type="RN"], node[type="master"]',
                        style: {
                            'background-color': '#4a9eff',
                            'border-color': '#0066cc',
                            'color': 'white'
                        }
                    },
                    {
                        selector: 'node[type="SN"], node[type="slave"]',
                        style: {
                            'background-color': '#52c41a',
                            'border-color': '#389e0d',
                            'color': 'white'
                        }
                    },
                    {
                        selector: 'node[type="HN"], node[type="relay"]',
                        style: {
                            'background-color': '#ff7a45',
                            'border-color': '#d4380d',
                            'color': 'white'
                        }
                    },
                    {
                        selector: 'edge',
                        style: {
                            'width': 2,
                            'line-color': '#999',
                            'target-arrow-color': '#999',
                            'target-arrow-shape': 'triangle',
                            'curve-style': 'bezier',
                            'label': 'data(label)',
                            'font-size': '10px',
                            'text-rotation': 'autorotate',
                            'text-margin-y': -10
                        }
                    },
                    {
                        selector: 'edge[label="Req"], edge[label="request"]',
                        style: {
                            'line-color': '#4a9eff',
                            'target-arrow-color': '#4a9eff'
                        }
                    },
                    {
                        selector: 'edge[label="Comp"], edge[label="response"]',
                        style: {
                            'line-color': '#52c41a',
                            'target-arrow-color': '#52c41a'
                        }
                    },
                    {
                        selector: 'edge[label="forward"]',
                        style: {
                            'line-color': '#ff7a45',
                            'target-arrow-color': '#ff7a45'
                        }
                    },
                    {
                        selector: 'edge[label="return"]',
                        style: {
                            'line-color': '#faad14',
                            'target-arrow-color': '#faad14'
                        }
                    }
                ]
            });

            // Register cytoscape-qtip plugin if available
            if (typeof cyqtip === 'function') {
                cyqtip(cytoscape);
            }

            // Hide all active tooltips
            function hideAllTooltips() {
                $('.qtip').qtip('hide');
            }

            // Add hover tooltip for nodes
            cy.on('mouseover', 'node', function(evt) {
                const node = evt.target;
                const data = node.data();
                let tooltip = `${data.label}\nID: ${data.id}\nType: ${data.type}`;
                
                // Display CHI protocol information
                if (data.payload && data.payload.chiProtocol) {
                    const nodeTypeMap = {'RN': 'Request Node (CHI)', 'HN': 'Home Node (CHI)', 'SN': 'Slave Node (CHI)'};
                    const chiType = data.payload.nodeType || data.type;
                    tooltip += `\nCHI Protocol: ${nodeTypeMap[chiType] || chiType}`;
                }
                
                if (data.queues && data.queues.length > 0) {
                    tooltip += '\n\nQueues:';
                    data.queues.forEach(q => {
                        const cap = q.capacity === -1 ? '∞' : q.capacity;
                        tooltip += `\n${q.name}: ${q.length}/${cap}`;
                    });
                }

                if (data.payload) {
                    tooltip += '\n\nStats:';
                    for (const [key, value] of Object.entries(data.payload)) {
                        // Skip internal CHI protocol fields in tooltip
                        if (key === 'chiProtocol' || key === 'nodeType') continue;
                        if (typeof value === 'number') {
                            tooltip += `\n${key}: ${value.toFixed(2)}`;
                        } else {
                            tooltip += `\n${key}: ${value}`;
                        }
                    }
                }

                let api = node.qtip('api');
                if (!api) {
                    node.qtip({
                        content: {
                            text: tooltip
                        },
                        position: {
                            my: 'top center',
                            at: 'bottom center',
                            viewport: document.getElementById('cy'),
                            adjust: {
                                method: 'flip shift'
                            }
                        },
                        style: {
                            classes: 'qtip-bootstrap',
                            tip: {
                                width: 16,
                                height: 8
                            }
                        },
                        show: {
                            event: 'mouseover',
                            solo: true
                        },
                        hide: {
                            event: 'mouseout',
                            fixed: true,
                            delay: 200
                        }
                    });
                    api = node.qtip('api');
                }

                if (api && typeof api.set === 'function') {
                    api.set('content.text', tooltip);
                }
            });

            // Add click event for nodes to show packet information
            cy.on('tap', 'node', function(evt) {
                const node = evt.target;
                const data = node.data();
                showPacketModal(data);
            });

            // Add hover tooltip for edges to show pipeline stages
            cy.on('mouseover', 'edge', function(evt) {
                const edge = evt.target;
                const data = edge.data();
                let tooltip = `${data.label}\nSource: ${data.source} → Target: ${data.target}`;
                
                if (data.pipelineStages && data.pipelineStages.length > 0) {
                    tooltip += '\n\nPipeline Stages:';
                    data.pipelineStages.forEach(stage => {
                        tooltip += `\nStage ${stage.stageIndex}: ${stage.packetCount} packet(s)`;
                    });
                    
                    // Indicate potential backpressure if Slot[0] has packets
                    if (data.pipelineStages[0] && data.pipelineStages[0].packetCount > 0) {
                        tooltip += '\n\n⚠ Slot[0] has packets (may indicate backpressure)';
                    }
                } else {
                    tooltip += '\n\nNo pipeline data available';
                }

                let api = edge.qtip('api');
                if (!api) {
                    edge.qtip({
                        content: {
                            text: tooltip
                        },
                        position: {
                            my: 'top center',
                            at: 'bottom center',
                            viewport: document.getElementById('cy'),
                            adjust: {
                                method: 'flip shift'
                            }
                        },
                        style: {
                            classes: 'qtip-bootstrap',
                            tip: {
                                width: 16,
                                height: 8
                            }
                        },
                        show: {
                            event: 'mouseover',
                            solo: true
                        },
                        hide: {
                            event: 'mouseout',
                            fixed: true,
                            delay: 200
                        }
                    });
                    api = edge.qtip('api');
                }

                if (api && typeof api.set === 'function') {
                    api.set('content.text', tooltip);
                }
            });

            // Update pipeline state points when view changes (pan, zoom, render)
            cy.on('render', function() {
                if (currentFrame) {
                    drawPipelineStatePoints(currentFrame);
                }
            });
            
            // Recalculate points on pan (translation)
            cy.on('pan', function() {
                hideAllTooltips();
                if (currentFrame) {
                    drawPipelineStatePoints(currentFrame);
                }
            });
            
            // Recalculate points on zoom
            cy.on('zoom', function() {
                hideAllTooltips();
                if (currentFrame) {
                    drawPipelineStatePoints(currentFrame);
                }
            });
            
            // Recalculate points on panzoom (combined pan and zoom)
            cy.on('panzoom', function() {
                hideAllTooltips();
                if (currentFrame) {
                    drawPipelineStatePoints(currentFrame);
                }
            });
        }

        // Format CHI protocol field values for display
        function formatCHIField(field, value) {
            if (value === undefined || value === null || value === '') {
                return 'N/A';
            }
            
            if (field === 'transactionType') {
                const typeMap = {
                    'ReadNoSnp': 'ReadNoSnp',
                    'WriteNoSnp': 'WriteNoSnp',
                    'ReadOnce': 'ReadOnce',
                    'WriteUnique': 'WriteUnique'
                };
                return typeMap[value] || value;
            }
            
            if (field === 'messageType') {
                const typeMap = {
                    'Req': 'Request',
                    'Resp': 'Response',
                    'Data': 'Data',
                    'Comp': 'Completion'
                };
                return typeMap[value] || value;
            }
            
            if (field === 'responseType') {
                const typeMap = {
                    'CompData': 'CompData (Completion with Data)',
                    'CompAck': 'CompAck (Completion Acknowledgment)'
                };
                return typeMap[value] || value;
            }
            
            if (field === 'address') {
                return '0x' + value.toString(16).toUpperCase().padStart(16, '0');
            }
            
            if (field === 'type') {
                return value.charAt(0).toUpperCase() + value.slice(1);
            }
            
            return value;
        }

        // Format packet information for display
        function formatPacketInfo(packet) {
            const fields = [
                { label: 'Packet ID', key: 'id', format: (v) => v },
                { label: 'Type', key: 'type', format: (v) => formatCHIField('type', v) },
                { label: 'Source Node ID', key: 'srcID', format: (v) => v !== undefined ? v : 'N/A' },
                { label: 'Destination Node ID', key: 'dstID', format: (v) => v !== undefined ? v : 'N/A' },
                { label: 'Master ID', key: 'masterID', format: (v) => v !== undefined ? v : 'N/A' },
                { label: 'Request ID', key: 'requestID', format: (v) => v !== undefined ? v : 'N/A' },
                { label: 'Transaction Type', key: 'transactionType', format: (v) => formatCHIField('transactionType', v) },
                { label: 'Message Type', key: 'messageType', format: (v) => formatCHIField('messageType', v) },
                { label: 'Response Type', key: 'responseType', format: (v) => formatCHIField('responseType', v) },
                { label: 'Address', key: 'address', format: (v) => v !== undefined ? formatCHIField('address', v) : 'N/A' },
                { label: 'Data Size (bytes)', key: 'dataSize', format: (v) => v !== undefined ? v : 'N/A' },
                { label: 'Generated At (cycle)', key: 'generatedAt', format: (v) => v !== undefined && v !== 0 ? v : 'N/A' },
                { label: 'Sent At (cycle)', key: 'sentAt', format: (v) => v !== undefined && v !== 0 ? v : 'N/A' },
                { label: 'Received At (cycle)', key: 'receivedAt', format: (v) => v !== undefined && v !== 0 ? v : 'N/A' },
                { label: 'Completed At (cycle)', key: 'completedAt', format: (v) => v !== undefined && v !== 0 ? v : 'N/A' }
            ];
            
            let html = '<table class="packet-table">';
            fields.forEach(field => {
                const value = packet[field.key];
                if (value !== undefined && value !== null && value !== '') {
                    html += `<tr><td class="packet-field-label">${field.label}:</td><td class="packet-field-value">${field.format(value)}</td></tr>`;
                }
            });
            html += '</table>';
            return html;
        }

        // Show packet modal with node information
        function showPacketModal(nodeData) {
            const modal = document.getElementById('packetModal');
            const modalTitle = document.getElementById('modalTitle');
            const modalBody = document.getElementById('modalBody');
            
            modalTitle.textContent = `${nodeData.label || 'Node'} - Packet Information`;
            
            let html = '';
            
            if (!nodeData.queues || nodeData.queues.length === 0) {
                html = '<div class="queue-section empty">No queues found for this node.</div>';
            } else {
                nodeData.queues.forEach(queue => {
                    html += `<div class="queue-section">`;
                    html += `<h3>${queue.name} (${queue.length}/${queue.capacity === -1 ? '∞' : queue.capacity})</h3>`;
                    
                    if (!queue.packets || queue.packets.length === 0) {
                        html += '<div class="empty">This queue is empty.</div>';
                    } else {
                        queue.packets.forEach((packet, index) => {
                            html += `<div class="packet-item">`;
                            html += `<div class="packet-item-header">Packet #${index + 1} (ID: <span class="packet-id">${packet.id}</span>)</div>`;
                            html += `<div class="packet-item-body">`;
                            html += formatPacketInfo(packet);
                            html += `</div></div>`;
                        });
                    }
                    
                    html += `</div>`;
                });
            }
            
            modalBody.innerHTML = html;
            modal.classList.add('show');
        }

        // Close modal
        function closePacketModal() {
            const modal = document.getElementById('packetModal');
            modal.classList.remove('show');
        }

        // Draw pipeline state points on edges using Cytoscape's midpoint API
        function drawPipelineStatePoints(frame) {
            const overlay = document.getElementById('pipelineOverlay');
            if (!overlay) {
                return;
            }

            // Clear existing points first, before any validation
            overlay.innerHTML = '';

            if (!frame || !frame.edges || !cy) {
                return;
            }

            // Get container position for coordinate conversion
            const container = document.getElementById('cy');
            const containerRect = container.getBoundingClientRect();

            frame.edges.forEach(edge => {
                const edgeId = `e${edge.source}-${edge.target}`;
                const cyEdge = cy.getElementById(edgeId);
                
                if (cyEdge.length === 0) {
                    return;
                }

                // Get the first edge element from the collection
                const cyEdgeElement = cyEdge[0];

                // Get data from both frame edge and Cytoscape edge (Cytoscape edge has the latest data)
                const edgeData = cyEdgeElement.data();
                const latency = edgeData.latency || edge.latency || 1;
                const bandwidthLimit = edgeData.bandwidthLimit || edge.bandwidthLimit || 1;
                const pipelineStages = edgeData.pipelineStages || edge.pipelineStages || [];

                // Validate values before drawing
                if (!latency || latency <= 0 || !isFinite(latency)) {
                    return;
                }
                if (!bandwidthLimit || bandwidthLimit <= 0 || !isFinite(bandwidthLimit)) {
                    return;
                }

                // Draw points using Cytoscape's midpoint API
                drawPointsOnEdge(cyEdgeElement, edge, latency, bandwidthLimit, pipelineStages, overlay);
            });

            // Update SVG size to match container
            overlay.setAttribute('width', containerRect.width);
            overlay.setAttribute('height', containerRect.height);
        }

        // Draw pipeline state points on a single edge using Cytoscape's midpoint API
        // Implementation: Use Cytoscape's midpoint() API + linear interpolation
        // This avoids manual Bezier curve calculation and ensures coordinate alignment
        function drawPointsOnEdge(cyEdge, edge, latency, bandwidthLimit, pipelineStages, overlay) {
            const container = document.getElementById('cy');
            if (!container) {
                return;
            }
            const containerRect = container.getBoundingClientRect();

            // Validate input parameters
            if (!latency || latency <= 0 || !isFinite(latency)) {
                return;
            }
            if (!bandwidthLimit || bandwidthLimit <= 0 || !isFinite(bandwidthLimit)) {
                return;
            }

            // Create a mapping of stageIndex to PacketCount
            const stageMap = {};
            if (pipelineStages && Array.isArray(pipelineStages)) {
                pipelineStages.forEach(stage => {
                    if (stage && typeof stage.stageIndex === 'number' && typeof stage.packetCount === 'number') {
                        stageMap[stage.stageIndex] = stage.packetCount;
                    }
                });
            }

            // Get source and target nodes
            const sourceNode = cyEdge.source();
            const targetNode = cyEdge.target();
            
            if (!sourceNode || !targetNode || sourceNode.length === 0 || targetNode.length === 0) {
                console.warn('Edge source or target node not found');
                return;
            }

            // Get source and target endpoint positions using renderedPosition()
            // renderedPosition() returns coordinates relative to the Cytoscape container
            // which matches the SVG overlay coordinate system
            let sourcePos, targetPos;
            
            try {
                // Use renderedPosition() which already accounts for zoom and pan
                // and returns coordinates relative to the container
                sourcePos = sourceNode.renderedPosition();
                targetPos = targetNode.renderedPosition();
                
                // Validate positions
                if (!sourcePos || !targetPos ||
                    !isFinite(sourcePos.x) || !isFinite(sourcePos.y) ||
                    !isFinite(targetPos.x) || !isFinite(targetPos.y)) {
                    throw new Error('renderedPosition() returned invalid values');
                }
            } catch (e) {
                console.warn('Failed to get edge positions using renderedPosition():', e);
                // Fallback: try position() and convert manually
                try {
                    const srcModelPos = sourceNode.position();
                    const tgtModelPos = targetNode.position();
                    const zoom = cy.zoom();
                    const pan = cy.pan();
                    
                    if (isFinite(srcModelPos.x) && isFinite(srcModelPos.y) &&
                        isFinite(tgtModelPos.x) && isFinite(tgtModelPos.y)) {
                        sourcePos = {
                            x: srcModelPos.x * zoom + pan.x,
                            y: srcModelPos.y * zoom + pan.y
                        };
                        targetPos = {
                            x: tgtModelPos.x * zoom + pan.x,
                            y: tgtModelPos.y * zoom + pan.y
                        };
                    } else {
                        throw new Error('position() also returned invalid values');
                    }
                } catch (e2) {
                    console.warn('All methods failed to get edge positions:', e2);
                    return;
                }
            }

            // Get midpoint using Cytoscape's midpoint() API
            // IMPORTANT: midpoint() returns MODEL coordinates, not rendered coordinates
            // We need to convert them to rendered coordinates using zoom and pan
            let midPoint;
            try {
                // Get midpoint in model coordinates
                const midPointModel = cyEdge.midpoint();
                
                // Validate model midpoint
                if (midPointModel && isFinite(midPointModel.x) && isFinite(midPointModel.y)) {
                    // Convert model coordinates to rendered coordinates
                    const zoom = cy.zoom();
                    const pan = cy.pan();
                    midPoint = {
                        x: midPointModel.x * zoom + pan.x,
                        y: midPointModel.y * zoom + pan.y
                    };
                } else {
                    // Fallback: calculate from rendered source and target positions
                    midPoint = {
                        x: (sourcePos.x + targetPos.x) / 2,
                        y: (sourcePos.y + targetPos.y) / 2
                    };
                }
            } catch (e) {
                // Fallback: calculate midpoint manually from rendered positions
                midPoint = {
                    x: (sourcePos.x + targetPos.x) / 2,
                    y: (sourcePos.y + targetPos.y) / 2
                };
            }
            
            // Final validation
            if (!isFinite(midPoint.x) || !isFinite(midPoint.y)) {
                console.warn('Failed to get valid midpoint');
                return;
            }

            // Draw points for each stage using linear interpolation
            // Interpolate between source, midpoint, and target to approximate curve position
            for (let stageIdx = 0; stageIdx < latency; stageIdx++) {
                // Calculate position ratio along the edge
                // Slot[0] (first stage, ready to arrive) should be near target
                // Slot[latency-1] (last stage, entry point) near source
                let ratio;
                if (latency === 1) {
                    ratio = 0.5; // Single stage at midpoint
                } else {
                    // Distribute points from 40% to 60% of the edge to avoid node overlap
                    // Map stageIdx from [0, latency-1] to [0.6, 0.4] (reversed)
                    ratio = 0.6 - (stageIdx / (latency - 1)) * 0.2;
                }

                // Linear interpolation between source, midpoint, and target
                // This approximates the curve position for better alignment
                let pointX, pointY;
                if (ratio <= 0.5) {
                    // Between source and midpoint
                    const t = ratio * 2; // Map [0, 0.5] to [0, 1]
                    pointX = sourcePos.x + (midPoint.x - sourcePos.x) * t;
                    pointY = sourcePos.y + (midPoint.y - sourcePos.y) * t;
                } else {
                    // Between midpoint and target
                    const t = (ratio - 0.5) * 2; // Map [0.5, 1] to [0, 1]
                    pointX = midPoint.x + (targetPos.x - midPoint.x) * t;
                    pointY = midPoint.y + (targetPos.y - midPoint.y) * t;
                }

                // Calculate perpendicular direction at the interpolated point
                // For linear interpolation, use the local direction vector
                // This is the direction from the previous point to the next point along the edge
                let dirX, dirY;
                if (ratio <= 0.5) {
                    // Direction from source to midpoint
                    dirX = midPoint.x - sourcePos.x;
                    dirY = midPoint.y - sourcePos.y;
                } else {
                    // Direction from midpoint to target
                    dirX = targetPos.x - midPoint.x;
                    dirY = targetPos.y - midPoint.y;
                }
                
                const length = Math.sqrt(dirX * dirX + dirY * dirY);
                let perpDir = { x: 0, y: 1 }; // Default vertical
                if (length > 0) {
                    // Perpendicular vector (rotated 90 degrees clockwise)
                    perpDir = {
                        x: dirY / length,
                        y: -dirX / length
                    };
                }

                const packetCount = stageMap[stageIdx] || 0;
                const pointSpacing = 4;
                const totalWidth = (bandwidthLimit - 1) * pointSpacing;
                const startOffset = -totalWidth / 2;

                // Validate interpolated point position
                if (!isFinite(pointX) || !isFinite(pointY)) {
                    console.warn(`Invalid point position for stage ${stageIdx}:`, { pointX, pointY });
                    continue;
                }

                // Draw points for this stage
                for (let i = 0; i < bandwidthLimit; i++) {
                    const offsetX = startOffset + i * pointSpacing;
                    const finalX = pointX + perpDir.x * offsetX;
                    const finalY = pointY + perpDir.y * offsetX;

                    // Validate final coordinates before drawing
                    if (!isFinite(finalX) || !isFinite(finalY)) {
                        console.warn(`Invalid final coordinates for stage ${stageIdx}, point ${i}:`, { finalX, finalY });
                        continue;
                    }

                    const isFilled = i < packetCount;
                    const color = isFilled ? '#ff4d4f' : '#999';
                    const radius = 3;

                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('cx', finalX);
                    circle.setAttribute('cy', finalY);
                    circle.setAttribute('r', radius);
                    circle.setAttribute('fill', color);
                    circle.setAttribute('stroke', '#fff');
                    circle.setAttribute('stroke-width', '0.5');
                    overlay.appendChild(circle);
                }
            }
        }

        // Fetch frame data from API
        async function fetchFrame() {
            try {
                const response = await fetch('/api/frame');
                if (!response.ok) {
                    if (response.status === 404) {
                        return null; // No frame available yet
                    }
                    throw new Error(`HTTP ${response.status}`);
                }
                const frame = await response.json();
                return frame;
            } catch (error) {
                console.error('Error fetching frame:', error);
                showError('Failed to fetch simulation data: ' + error.message);
                return null;
            }
        }

        // Update visualization with frame data
        function updateVisualization(frame) {
            if (!frame || !frame.nodes || !frame.edges) {
                return;
            }

            currentFrame = frame;

            // Check for config change using configHash from frame
            const configHash = frame.configHash || null;
            let shouldReinitialize = false;

            if (expectingReset && frame.cycle === 0) {
                // This is the reset frame we were waiting for
                shouldReinitialize = true;
                expectingReset = false;
                console.log('[DEBUG] Received reset frame (cycle 0), reinitializing topology');
            } else if (configHash && lastConfigHash !== null && configHash !== lastConfigHash) {
                // Config hash changed, network structure has changed
                shouldReinitialize = true;
                console.log('[DEBUG] Config hash changed:', lastConfigHash, '->', configHash, ', reinitializing topology');
            } else if (lastConfigHash === null && configHash) {
                // First frame with config hash, initialize it
                lastConfigHash = configHash;
            }

            if (shouldReinitialize) {
                cy.elements().remove();
                topologyInitialized = false;
                // Update lastConfigHash if configHash is available
                if (configHash) {
                    lastConfigHash = configHash;
                }
            }

            // Update status info
            document.getElementById('currentCycle').textContent = frame.cycle || 0;
            document.getElementById('inFlightCount').textContent = frame.inFlightCount || 0;
            
            const statusEl = document.getElementById('simStatus');
            if (frame.cycle >= (frame.totalCycles || 1000)) {
                statusEl.innerHTML = 'Status: <strong style="color: #52c41a;">Completed</strong>';
            } else {
                statusEl.innerHTML = 'Status: <strong style="color: #1890ff;">Running</strong>';
            }

            // Update button states based on current pause status
            updateButtonStates();

            // Initialize topology on first frame or after config change
            if (!topologyInitialized) {
                const elements = [];

                // Add nodes
                frame.nodes.forEach(node => {
                    const queues = node.queues || [];
                    const nodeWidth = 60;
                    const baseHeight = 60;
                    const progressBarHeight = queues.length > 0 ? queues.length * 3 + (queues.length - 1) * 1 + 4 : 0;
                    const nodeHeight = baseHeight + progressBarHeight;
                    
                    const progressBg = createProgressBarsSVG(queues, nodeWidth, nodeHeight);
                    
                    const nodeData = {
                        group: 'nodes',
                        data: {
                            id: String(node.id),
                            label: node.label || `Node ${node.id}`,
                            type: node.type,
                            queues: queues,
                            payload: node.payload || {},
                            height: nodeHeight,
                            progressBg: progressBg
                        }
                    };
                    elements.push(nodeData);
                });

                // Add edges
                frame.edges.forEach(edge => {
                    const edgeLabel = `${edge.label} (${edge.latency}cy)`;
                    const pipelineStages = edge.pipelineStages || [];
                    elements.push({
                        group: 'edges',
                        data: {
                            id: `e${edge.source}-${edge.target}`,
                            source: String(edge.source),
                            target: String(edge.target),
                            label: edgeLabel,
                            latency: edge.latency,
                            pipelineStages: pipelineStages,
                            bandwidthLimit: edge.bandwidthLimit
                        }
                    });
                });

                // Add all elements
                cy.add(elements);
                
                // Apply custom layout after elements are added
                // Use setTimeout to ensure Cytoscape has processed the elements
                setTimeout(() => {
                    applyCustomLayout();
                }, 50);
                
                topologyInitialized = true;
                // Update current config name after topology is initialized
                const newConfigName = getConfigFromForm();
                currentConfigName = newConfigName;
                // Update lastConfigHash if we have it from frame
                if (frame.configHash) {
                    lastConfigHash = frame.configHash;
                }
            }

            // Update existing nodes with new data (without re-layout)
            frame.nodes.forEach(node => {
                const nodeId = String(node.id);
                const cyNode = cy.getElementById(nodeId);
                
                if (cyNode.length > 0) {
                    const queues = node.queues || [];
                    const nodeWidth = 60;
                    const baseHeight = 60;
                    const progressBarHeight = queues.length > 0 ? queues.length * 3 + (queues.length - 1) * 1 + 4 : 0;
                    const nodeHeight = baseHeight + progressBarHeight;
                    
                    const progressBg = createProgressBarsSVG(queues, nodeWidth, nodeHeight);
                    
                    // Update node data
                    let label = node.label || `Node ${node.id}`;
                    if (queues.length > 0) {
                        const queueInfo = queues.map(q => {
                            const cap = q.capacity === -1 ? '∞' : q.capacity;
                            return `${q.name}:${q.length}/${cap}`;
                        }).join(' ');
                        label += `\n${queueInfo}`;
                    }

                    cyNode.data({
                        label: label,
                        queues: queues,
                        payload: node.payload || {},
                        height: nodeHeight,
                        progressBg: progressBg
                    });
                }
            });

            // Update existing edges with pipeline stages
            frame.edges.forEach(edge => {
                const edgeId = `e${edge.source}-${edge.target}`;
                const cyEdge = cy.getElementById(edgeId);
                
                if (cyEdge.length > 0) {
                    const pipelineStages = edge.pipelineStages || [];
                    let edgeLabel = `${edge.label} (${edge.latency}cy)`;
                    
                    cyEdge.data({
                        label: edgeLabel,
                        pipelineStages: pipelineStages,
                        bandwidthLimit: edge.bandwidthLimit
                    });
                    
                    // Update edge style based on backpressure (Slot[0] has packets but can't advance)
                    if (pipelineStages.length > 0 && pipelineStages[0].packetCount > 0) {
                        // Check if this indicates backpressure (would need receiver state, simplified here)
                        cyEdge.style('line-color', '#ff4d4f'); // Red for potential backpressure
                        cyEdge.style('width', 3);
                    } else {
                        cyEdge.style('line-color', '#91d5ff'); // Blue for normal
                        cyEdge.style('width', 2);
                    }
                }
            });

            // Draw pipeline state points
            drawPipelineStatePoints(frame);

            // Update statistics
            updateStatistics(frame.stats);
        }

        // Update statistics panel
        function updateStatistics(stats) {
            const panel = document.getElementById('statsPanel');
            if (!stats || !stats.Global) {
                panel.innerHTML = '<div class="stats-item"><div style="text-align: center; color: #999;">No data available</div></div>';
                return;
            }

            let html = '';

            // Global stats
            html += '<div class="stats-item">';
            html += '<h4>Global Statistics</h4>';
            html += '<div class="stats-grid">';
            html += `<div class="stats-value">Total Requests: <strong>${stats.Global.TotalRequests}</strong></div>`;
            html += `<div class="stats-value">Completed: <strong>${stats.Global.Completed}</strong></div>`;
            html += `<div class="stats-value">Completion Rate: <strong>${stats.Global.CompletionRate.toFixed(2)}%</strong></div>`;
            html += `<div class="stats-value">Avg Delay: <strong>${stats.Global.AvgEndToEndDelay.toFixed(2)} cy</strong></div>`;
            html += `<div class="stats-value">Max Delay: <strong>${stats.Global.MaxDelay} cy</strong></div>`;
            html += `<div class="stats-value">Min Delay: <strong>${stats.Global.MinDelay} cy</strong></div>`;
            html += '</div>';
            html += '</div>';

            // Master stats
            if (stats.PerMaster && stats.PerMaster.length > 0) {
                html += '<div class="stats-item">';
                html += '<h4>Master Statistics</h4>';
                stats.PerMaster.forEach((m, idx) => {
                    if (m) {
                        html += `<div style="margin-top: 6px; padding-top: 6px; border-top: 1px solid #eee;">`;
                        html += `<strong>Master ${idx}</strong><br>`;
                        html += `Completed: ${m.CompletedRequests}, `;
                        html += `Avg Delay: ${m.AvgDelay.toFixed(2)} cy, `;
                        html += `Max: ${m.MaxDelay} cy, Min: ${m.MinDelay} cy`;
                        html += '</div>';
                    }
                });
                html += '</div>';
            }

            // Slave stats
            if (stats.PerSlave && stats.PerSlave.length > 0) {
                html += '<div class="stats-item">';
                html += '<h4>Slave Statistics</h4>';
                stats.PerSlave.forEach((s, idx) => {
                    if (s) {
                        html += `<div style="margin-top: 6px; padding-top: 6px; border-top: 1px solid #eee;">`;
                        html += `<strong>Slave ${idx}</strong><br>`;
                        html += `Processed: ${s.TotalProcessed}, `;
                        html += `Max Queue: ${s.MaxQueueLength}, `;
                        html += `Avg Queue: ${s.AvgQueueLength.toFixed(2)}`;
                        html += '</div>';
                    }
                });
                html += '</div>';
            }

            panel.innerHTML = html;
        }

        // Send control command (prefer WebSocket, fallback to HTTP)
        async function sendControl(type, configName, totalCycles) {
            const body = { type: type };
            if (configName) {
                body.configName = configName;
            }
            if (totalCycles !== undefined && totalCycles !== null) {
                body.totalCycles = totalCycles;
            }

            // Try WebSocket first if connected
            if (ws && ws.readyState === WebSocket.OPEN) {
                try {
                    ws.send(JSON.stringify(body));
                    hideError();
                    return true;
                } catch (error) {
                    console.warn('[WebSocket] Failed to send via WebSocket, falling back to HTTP:', error);
                }
            }

            // Fallback to HTTP
            try {
                const response = await fetch('/api/control', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(body)
                });

                if (!response.ok) {
                    const text = await response.text();
                    throw new Error(text || `HTTP ${response.status}`);
                }

                hideError();
                return true;
            } catch (error) {
                console.error('Error sending control:', error);
                showError('Failed to send command: ' + error.message);
                return false;
            }
        }

        // Load available network configurations
        async function loadConfigurations() {
            try {
                const response = await fetch('/api/configs');
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                const configs = await response.json();
                
                const select = document.getElementById('networkConfig');
                select.innerHTML = '';
                
                if (configs.length === 0) {
                    select.innerHTML = '<option value="">No configurations available</option>';
                    return;
                }
                
                configs.forEach((cfg, index) => {
                    const option = document.createElement('option');
                    option.value = cfg.name;
                    option.textContent = cfg.description;
                    if (index === 0) {
                        option.selected = true;
                    }
                    select.appendChild(option);
                });
            } catch (error) {
                console.error('Error loading configurations:', error);
                const select = document.getElementById('networkConfig');
                select.innerHTML = '<option value="">Error loading configurations</option>';
                showError('Failed to load network configurations: ' + error.message);
            }
        }

        // Get selected configuration name from form
        function getConfigFromForm() {
            const select = document.getElementById('networkConfig');
            return select.value;
        }

        // Validate configuration
        function validateConfig(configName) {
            if (!configName) {
                return 'Please select a network configuration';
            }
            const totalCycles = parseInt(document.getElementById('totalCycles').value);
            if (isNaN(totalCycles) || totalCycles <= 0) {
                return 'TotalCycles must be a positive number';
            }
            return null;
        }

        // Show error message
        function showError(message) {
            const errorEl = document.getElementById('errorMessage');
            errorEl.textContent = message;
            errorEl.classList.add('show');
        }

        // Hide error message
        function hideError() {
            const errorEl = document.getElementById('errorMessage');
            errorEl.classList.remove('show');
        }

        // Fetch frame immediately (used after step commands)
        async function fetchFrameImmediate() {
            const frame = await fetchFrame();
            if (frame) {
                updateVisualization(frame);
            }
            return frame;
        }

        // Connect to WebSocket for real-time updates
        function connectWebSocket() {
            // Close existing connection if any
            if (ws) {
                ws.close();
                ws = null;
            }

            // Clear any pending reconnect
            if (wsReconnectTimeout) {
                clearTimeout(wsReconnectTimeout);
                wsReconnectTimeout = null;
            }

            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws`;
            
            try {
                ws = new WebSocket(wsUrl);

                ws.onopen = () => {
                    console.log('[WebSocket] Connected');
                    hideError();
                };

                ws.onmessage = (event) => {
                    try {
                        const frame = JSON.parse(event.data);
                        if (frame) {
                            updateVisualization(frame);
                        }
                    } catch (error) {
                        console.error('[WebSocket] Error parsing frame:', error);
                    }
                };

                ws.onerror = (error) => {
                    console.error('[WebSocket] Error:', error);
                    showError('WebSocket connection error. Please refresh the page to reconnect.');
                };

                ws.onclose = () => {
                    console.log('[WebSocket] Disconnected');
                    ws = null;
                    // Attempt to reconnect after 2 seconds
                    wsReconnectTimeout = setTimeout(() => {
                        console.log('[WebSocket] Attempting to reconnect...');
                        connectWebSocket();
                    }, 2000);
                };
            } catch (error) {
                console.error('[WebSocket] Failed to connect:', error);
                showError('WebSocket connection failed. Please refresh the page to reconnect.');
            }
        }

        // Disconnect WebSocket
        function disconnectWebSocket() {
            if (wsReconnectTimeout) {
                clearTimeout(wsReconnectTimeout);
                wsReconnectTimeout = null;
            }
            if (ws) {
                ws.close();
                ws = null;
            }
        }

        // Update button states based on pause status
        function updateButtonStates() {
            const btnPause = document.getElementById('btnPause');
            const btnResume = document.getElementById('btnResume');
            const btnStep = document.getElementById('btnStep');
            
            if (btnPause) {
                btnPause.disabled = isPaused; // Disable when paused
            }
            if (btnResume) {
                btnResume.disabled = !isPaused; // Disable when running
            }
            if (btnStep) {
                // Disable step button if not paused or if a step is being processed
                btnStep.disabled = !isPaused || isStepProcessing;
            }
        }

        // Event listeners
        document.getElementById('btnPause').addEventListener('click', async () => {
            const success = await sendControl('pause');
            if (success) {
                isPaused = true;
                updateButtonStates();
            }
        });

        document.getElementById('btnResume').addEventListener('click', async () => {
            const success = await sendControl('resume');
            if (success) {
                isPaused = false;
                updateButtonStates();
            }
        });

        document.getElementById('btnStep').addEventListener('click', async () => {
            if (!isPaused || isStepProcessing) {
                return; // Step button should only work when paused and not processing
            }
            
            // Set processing flag to prevent duplicate clicks
            isStepProcessing = true;
            updateButtonStates();
            
            try {
                const success = await sendControl('step');
                if (success) {
                    // Step command sent, immediately fetch frame to get updated state
                    // Wait a short time for simulator to process the step
                    await new Promise(resolve => setTimeout(resolve, 100));
                    
                    // Try to fetch frame multiple times with short delays to ensure we get the update
                    let frame = null;
                    for (let i = 0; i < 5; i++) {
                        frame = await fetchFrameImmediate();
                        if (frame) {
                            break;
                        }
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }
                }
            } finally {
                // Reset processing flag after a delay to allow for visual feedback
                setTimeout(() => {
                    isStepProcessing = false;
                    updateButtonStates();
                }, 200);
            }
        });

        document.getElementById('btnReset').addEventListener('click', async () => {
            const configName = getConfigFromForm();
            const error = validateConfig(configName);
            if (error) {
                showError(error);
                return;
            }
            const totalCycles = parseInt(document.getElementById('totalCycles').value);
            const success = await sendControl('reset', configName, totalCycles);
            if (success) {
                isPaused = true; // Reset pauses at cycle 0
                updateButtonStates();
                // Clear visualization and reset topology
                cy.elements().remove();
                topologyInitialized = false;
                // Update current config name to track the new configuration
                currentConfigName = configName;
                // Set flag to wait for reset frame (cycle 0)
                expectingReset = true;
                console.log('[DEBUG] Reset clicked, waiting for cycle 0 frame');
                document.getElementById('currentCycle').textContent = '-';
                document.getElementById('inFlightCount').textContent = '-';
                document.getElementById('simStatus').innerHTML = 'Status: <strong>Resetting...</strong>';
            }
        });

        // Initialize
        loadConfigurations();
        initCytoscape();
        updateButtonStates(); // Set initial button states (paused at cycle 0)
        connectWebSocket(); // Connect to WebSocket for real-time updates

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            disconnectWebSocket();
        });

        // Modal close event listeners (initialize after DOM is ready)
        document.getElementById('modalClose').addEventListener('click', closePacketModal);
        document.getElementById('packetModal').addEventListener('click', function(e) {
            if (e.target === this) {
                closePacketModal();
            }
        });

        // Reapply layout on window resize
        let resizeTimeout;
        window.addEventListener('resize', () => {
            if (topologyInitialized) {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    applyCustomLayout();
                }, 250);
            }
        });

        // Initial frame fetch
        fetchFrame().then(frame => {
            if (frame) {
                updateVisualization(frame);
            }
        });

        // ===== Mermaid Sequence Diagram Functions =====

        /**
         * Convert node label to Mermaid-compatible alias
         */
        function sanitizeAlias(label) {
            // Mermaid alias can only contain letters, numbers, underscores
            return label.replace(/[^a-zA-Z0-9_]/g, '_');
        }

        /**
         * Sort nodes by type (RN -> HN -> SN)
         */
        function sortNodesByType(nodes) {
            const typeOrder = { 'RN': 0, 'HN': 1, 'SN': 2 };
            return [...nodes].sort((a, b) => {
                const orderA = typeOrder[a.type] ?? 999;
                const orderB = typeOrder[b.type] ?? 999;
                if (orderA !== orderB) return orderA - orderB;
                return a.id - b.id;
            });
        }

        /**
         * Infer message label from event
         * @param {PacketEvent} event - The packet event
         * @param {Array} allEvents - All events in the timeline (for looking up related events)
         * @param {Array} sortedNodes - Sorted array of nodes (for looking up node types)
         */
        function inferMessageLabel(event, allEvents, sortedNodes) {
            // Try to get from metadata first (for PacketSent events, this should contain MessageType)
            if (event.metadata && event.metadata.messageType) {
                const msgType = event.metadata.messageType;
                // Map CHI message types to display labels
                if (msgType === 'Snp') return 'Snp';
                if (msgType === 'SnpResp') return 'SnpResp';
                return msgType; // 'Req', 'Comp', etc.
            }
            
            // For PacketInTransitEnd, try to find the corresponding PacketSent event
            if (event.eventType === 'PacketInTransitEnd' && event.edgeKey && allEvents) {
                const sendEvent = allEvents.find(e => 
                    e.packetID === event.packetID &&
                    e.eventType === 'PacketSent' &&
                    e.edgeKey &&
                    e.edgeKey.fromID === event.edgeKey.fromID &&
                    e.edgeKey.toID === event.edgeKey.toID
                );
                if (sendEvent) {
                    // Try metadata first
                    if (sendEvent.metadata && sendEvent.metadata.messageType) {
                        return sendEvent.metadata.messageType;
                    }
                    // Check parent packet ID
                    if (sendEvent.parentPacketID && sendEvent.parentPacketID > 0) {
                        return 'Comp';
                    }
                }
            }
            
            // Check if this is a response packet (has parent packet ID)
            if (event.parentPacketID && event.parentPacketID > 0) {
                return 'Comp';
            }
            
            // Infer from node types and direction
            if (event.edgeKey && sortedNodes) {
                const fromNode = sortedNodes.find(n => n.id === event.edgeKey.fromID);
                const toNode = sortedNodes.find(n => n.id === event.edgeKey.toID);
                
                // If from SN/HN to RN, it's likely a response
                if (fromNode && toNode) {
                    const fromType = fromNode.type || '';
                    const toType = toNode.type || '';
                    if ((fromType === 'SN' || fromType === 'HN') && toType === 'RN') {
                        return 'Comp';
                    }
                    // If from RN to SN/HN, it's likely a request
                    if (fromType === 'RN' && (toType === 'SN' || toType === 'HN')) {
                        return 'Req';
                    }
                }
            }
            
            // Infer from event type
            switch (event.eventType) {
                case 'PacketSent':
                    return 'Req';
                case 'PacketGenerated':
                    return 'Comp';
                default:
                    return 'Message';
            }
        }

        /**
         * Build unique key for packet transmission on a specific edge
         */
        function buildPacketEdgeKey(packetID, edgeKey) {
            if (!edgeKey) {
                return null;
            }
            return `${packetID}:${edgeKey.fromID}->${edgeKey.toID}`;
        }

        /**
         * Clamp percent value to [0, 100] and trim trailing zeros
         */
        function formatPercent(value) {
            if (!Number.isFinite(value)) {
                return '0';
            }
            const clamped = Math.min(100, Math.max(0, value));
            const fixed = clamped.toFixed(2);
            return fixed.replace(/\.?0+$/, '');
        }

        /**
         * Convert TransactionTimeline data to Mermaid sequence diagram syntax
         * @param {TransactionTimeline} timeline - Transaction timeline data
         * @returns {string} Mermaid sequence diagram syntax string
         */
        function convertTimelineToMermaid(timeline) {
            const { events, nodes } = timeline;
            
            if (!events || events.length === 0) {
                return 'sequenceDiagram\n    Note over System: No events available';
            }

            // 1. Define node participants (sorted by type: RN -> HN -> SN)
            const sortedNodes = sortNodesByType(nodes);
            const nodeAliasMap = new Map();
            const participants = sortedNodes.map(node => {
                const alias = sanitizeAlias(node.label);
                nodeAliasMap.set(node.id, alias);
                return `    participant ${alias} as "${node.label}"`;
            });
            
            // 2. Sort events by cycle
            const sortedEvents = [...events].sort((a, b) => {
                if (a.cycle !== b.cycle) {
                    return a.cycle - b.cycle;
                }
                // If same cycle, use sequence to maintain order
                return (a.sequence || 0) - (b.sequence || 0);
            });
            
            const cycleValues = sortedEvents
                .map(e => (typeof e.cycle === 'number' ? e.cycle : null))
                .filter(c => c !== null);
            const minCycle = cycleValues.length ? Math.min(...cycleValues) : 0;
            const maxCycle = cycleValues.length ? Math.max(...cycleValues) : minCycle;
            const cycleRange = maxCycle - minCycle;

            function cycleToPercent(cycle) {
                if (!Number.isFinite(cycle)) {
                    return 0;
                }
                if (!Number.isFinite(minCycle) || cycleRange <= 0) {
                    return 0;
                }
                const normalized = ((cycle - minCycle) / cycleRange) * 100;
                return normalized;
            }

            function buildDirective(startPercent, endPercent) {
                return `[ys=${formatPercent(startPercent)}%,ye=${formatPercent(endPercent)}%]`;
            }

            function buildMessageDetails(sendCycle, receiveCycle) {
                if (!Number.isFinite(sendCycle)) {
                    return ` (cycle ${receiveCycle})`;
                }
                if (sendCycle === receiveCycle) {
                    return ` (cycle ${receiveCycle})`;
                }
                const parts = [`cycles ${sendCycle}→${receiveCycle}`];
                const delay = receiveCycle - sendCycle;
                if (delay > 0) {
                    parts.push(`delay ${delay}`);
                }
                return ` (${parts.join(', ')})`;
            }

            // 3. Build message sequence with activation boxes
            const messages = [];
            const activations = new Map(); // activationKey -> alias
            const sendEventMap = new Map(); // packetEdgeKey -> {fromAlias, toAlias, sendCycle, label}
            
            sortedEvents.forEach(event => {
                const cycle = event.cycle;
                const nodeAlias = nodeAliasMap.get(event.nodeID);
                
                switch (event.eventType) {
                    case 'PacketSent':
                        if (event.edgeKey) {
                            const fromAlias = nodeAliasMap.get(event.edgeKey.fromID);
                            const toAlias = nodeAliasMap.get(event.edgeKey.toID);
                            if (!fromAlias || !toAlias) break;
                            const key = buildPacketEdgeKey(event.packetID, event.edgeKey);
                            if (!key) break;
                            const messageLabel = inferMessageLabel(event, events, sortedNodes);
                            sendEventMap.set(key, {
                                fromAlias,
                                toAlias,
                                sendCycle: cycle,
                                label: messageLabel
                            });
                        }
                        break;
                        
                    case 'PacketInTransitEnd':
                        if (event.edgeKey) {
                            const key = buildPacketEdgeKey(event.packetID, event.edgeKey);
                            const fromAlias = nodeAliasMap.get(event.edgeKey.fromID);
                            const toAlias = nodeAliasMap.get(event.edgeKey.toID);
                            if (!fromAlias || !toAlias) break;
                            const sendInfo = key ? sendEventMap.get(key) : null;
                            const sendCycle = sendInfo ? sendInfo.sendCycle : cycle;
                            const receiveCycle = cycle;
                            const messageLabel = sendInfo ? sendInfo.label : inferMessageLabel(event, events, sortedNodes);

                            const directive = buildDirective(cycleToPercent(sendCycle), cycleToPercent(receiveCycle));
                            const details = buildMessageDetails(sendCycle, receiveCycle);
                            messages.push(`    ${fromAlias}->>${toAlias}: ${directive} ${messageLabel}${details}`);
                            if (key) {
                                sendEventMap.delete(key);
                            }
                        }
                        break;
                        
                    case 'PacketReceived':
                        // No visualization change needed here
                        break;
                        
                    case 'PacketEnqueued':
                        if (!nodeAlias) break;
                        const queueKey = `queue_${event.packetID}_${event.nodeID}`;
                        if (!activations.has(queueKey)) {
                            messages.push(`    activate ${nodeAlias}`);
                            activations.set(queueKey, nodeAlias);
                        }
                        break;
                        
                    case 'PacketDequeued':
                        if (!nodeAlias) break;
                        const dequeueKey = `queue_${event.packetID}_${event.nodeID}`;
                        if (activations.has(dequeueKey)) {
                            messages.push(`    deactivate ${nodeAlias}`);
                            activations.delete(dequeueKey);
                        }
                        break;
                        
                    case 'PacketProcessingStart':
                        if (!nodeAlias) break;
                        const processKey = `process_${event.packetID}_${event.nodeID}`;
                        if (!activations.has(processKey)) {
                            messages.push(`    activate ${nodeAlias}`);
                            activations.set(processKey, nodeAlias);
                        }
                        messages.push(`    Note over ${nodeAlias}: Processing (cycle ${cycle})`);
                        break;
                        
                    case 'PacketProcessingEnd':
                        if (!nodeAlias) break;
                        const processEndKey = `process_${event.packetID}_${event.nodeID}`;
                        if (activations.has(processEndKey)) {
                            messages.push(`    deactivate ${nodeAlias}`);
                            activations.delete(processEndKey);
                        }
                        break;
                        
                    case 'PacketGenerated':
                        // Node generated new message (self-loop)
                        if (!nodeAlias) break;
                        const messageLabel = inferMessageLabel(event, events, sortedNodes);
                        messages.push(`    ${nodeAlias}->>${nodeAlias}: ${messageLabel} (cycle ${cycle})`);
                        break;
                }
            });
            
            // Handle packets still in transit (no end event)
            sendEventMap.forEach(info => {
                const directive = buildDirective(cycleToPercent(info.sendCycle), cycleToPercent(info.sendCycle));
                const details = Number.isFinite(info.sendCycle) ? ` (cycle ${info.sendCycle}, pending)` : '';
                messages.push(`    ${info.fromAlias}->>${info.toAlias}: ${directive} ${info.label}${details}`);
            });

            // Close any remaining activation boxes
            activations.forEach(alias => {
                messages.push(`    deactivate ${alias}`);
            });
            
            // 4. Combine into complete Mermaid syntax
            const mermaidCode = `sequenceDiagram
${participants.join('\n')}

${messages.join('\n')}`;
            
            return mermaidCode;
        }

        /**
         * Parse directive string into structured parameters
         */
        function parseDirectiveStr(input) {
            const result = {};
            if (!input) {
                return result;
            }
            const parts = input.split(',').map(p => p.trim()).filter(Boolean);
            for (const part of parts) {
                let match = part.match(/^([a-zA-Z]+)\s*=\s*([+-]?\d+(\.\d+)?)%$/);
                if (match) {
                    const key = match[1];
                    result[key] = Number(match[2]);
                    result[`${key}Unit`] = 'percent';
                    continue;
                }
                match = part.match(/^([a-zA-Z]+)\s*=\s*([+-]?\d+(\.\d+)?)$/);
                if (match) {
                    const key = match[1];
                    result[key] = Number(match[2]);
                    result[`${key}Unit`] = 'absolute';
                }
            }
            return result;
        }

        /**
         * Inject tokens for directives prior to Mermaid rendering
         */
        function preprocessMermaidDiagram(diagramText) {
            const lines = diagramText.split('\n');
            const map = {};
            let counter = 0;

            const processed = lines.map(line => {
                if (!line.includes(':')) {
                    return line;
                }
                const idx = line.indexOf(':');
                const header = line.slice(0, idx);
                const message = line.slice(idx + 1);
                const match = message.match(/^\s*\[([^\]]+)\]\s*(.*)$/);
                if (!match) {
                    return line;
                }
                counter += 1;
                const directive = match[1];
                const restText = match[2] || '';
                const args = parseDirectiveStr(directive);
                const token = `__MSG_TOK_${Date.now()}_${counter}__`;
                map[token] = {
                    ...args,
                    orig: restText.trim()
                };
                const rebuilt = `${header}: ${token}${restText ? ` ${restText}` : ''}`;
                return rebuilt;
            }).join('\n');

            return { text: processed, map };
        }

        function clamp(value, min, max) {
            if (!Number.isFinite(value)) {
                return min;
            }
            return Math.min(Math.max(value, min), max);
        }

        /**
         * Extract start/end points from a path definition
         */
        function extractEndpointsFromPathD(d) {
            const nums = (d.match(/-?\d+\.?\d*/g) || []).map(Number);
            if (nums.length >= 4) {
                const x1 = nums[0];
                const y1 = nums[1];
                const x2 = nums[nums.length - 2];
                const y2 = nums[nums.length - 1];
                return { x1, y1, x2, y2 };
            }
            return null;
        }

        /**
         * Build a smooth cubic path between two points
         */
        function makeSmoothCubicPath(x1, y1, x2, y2) {
            const dx = (x2 - x1);
            const cp1x = x1 + dx * 0.25;
            const cp2x = x1 + dx * 0.75;
            const cp1y = y1 + (y2 - y1) * 0.15;
            const cp2y = y2 - (y2 - y1) * 0.15;
            return `M ${x1} ${y1} C ${cp1x} ${cp1y} ${cp2x} ${cp2y} ${x2} ${y2}`;
        }

        /**
         * Locate label elements containing a specific token
         */
        function findLabelElements(svgEl, token) {
            const texts = Array.from(svgEl.querySelectorAll('text')).filter(t => (t.textContent || '').includes(token));
            const foreigns = Array.from(svgEl.querySelectorAll('foreignObject')).filter(f => (f.textContent || '').includes(token));
            return texts.concat(foreigns);
        }

        /**
         * Safely get bounding box for an element
         */
        function safeGetBBox(el) {
            try {
                return el.getBBox();
            } catch (e) {
                const rect = el.getBoundingClientRect();
                return {
                    x: rect.x,
                    y: rect.y,
                    width: rect.width,
                    height: rect.height
                };
            }
        }

        /**
         * Apply directive-driven adjustments to the rendered SVG
         */
        async function postProcessMermaidSvg(svgEl, mapObj) {
            if (!mapObj || Object.keys(mapObj).length === 0) {
                return;
            }

            const allEdges = Array.from(svgEl.querySelectorAll('path, line'));
            let globalYMin = Infinity;
            let globalYMax = -Infinity;

            allEdges.forEach(edge => {
                try {
                    if (edge.tagName === 'line') {
                        const y1 = Number(edge.getAttribute('y1') || 0);
                        const y2 = Number(edge.getAttribute('y2') || 0);
                        globalYMin = Math.min(globalYMin, y1, y2);
                        globalYMax = Math.max(globalYMax, y1, y2);
                    } else {
                        const dAttr = edge.getAttribute('d') || '';
                        const pts = extractEndpointsFromPathD(dAttr);
                        if (pts) {
                            globalYMin = Math.min(globalYMin, pts.y1, pts.y2);
                            globalYMax = Math.max(globalYMax, pts.y1, pts.y2);
                        }
                    }
                } catch (error) {
                    // Ignore malformed edges
                }
            });

            if (!Number.isFinite(globalYMin) || !Number.isFinite(globalYMax)) {
                try {
                    const bbox = svgEl.getBBox();
                    globalYMin = bbox.y;
                    globalYMax = bbox.y + bbox.height;
                } catch (error) {
                    globalYMin = 0;
                    globalYMax = 0;
                }
            }

            const actorNodes = Array.from(svgEl.querySelectorAll('[class*=actor]'));
            const actorBoxes = [];
            actorNodes.forEach(node => {
                try {
                    const box = node.getBBox();
                    if (box && Number.isFinite(box.y) && Number.isFinite(box.height)) {
                        actorBoxes.push({
                            top: box.y,
                            bottom: box.y + box.height,
                            height: box.height
                        });
                    }
                } catch (_) {
                    const rect = node.getBoundingClientRect?.();
                    if (rect && Number.isFinite(rect.y) && Number.isFinite(rect.height)) {
                        actorBoxes.push({
                            top: rect.y,
                            bottom: rect.y + rect.height,
                            height: rect.height
                        });
                    }
                }
            });

            let percentBase = globalYMin;
            let percentRange = Math.max(1, globalYMax - globalYMin);
            const debugInfo = {
                globalYMin,
                globalYMax,
                actorCount: actorBoxes.length
            };

            if (actorBoxes.length > 0) {
                const minBottom = Math.min(...actorBoxes.map(b => b.bottom));
                const maxTop = Math.max(...actorBoxes.map(b => b.top));
                const avgHeight = actorBoxes.reduce((acc, b) => acc + b.height, 0) / actorBoxes.length;
                const dynamicPad = clamp(avgHeight * 0.3, 8, 40);
                const startCandidate = Math.max(globalYMin, minBottom + dynamicPad);
                const endCandidate = Math.min(globalYMax, maxTop - dynamicPad);

                debugInfo.minBottom = minBottom;
                debugInfo.maxTop = maxTop;
                debugInfo.dynamicPad = dynamicPad;

                if (Number.isFinite(startCandidate) && Number.isFinite(endCandidate) && endCandidate - startCandidate >= 4) {
                    percentBase = startCandidate;
                    percentRange = endCandidate - startCandidate;
                    debugInfo.start = percentBase;
                    debugInfo.end = percentBase + percentRange;
                } else {
                    const fallbackPad = clamp((globalYMax - globalYMin) * 0.05, 8, 40);
                    const fallbackStart = Math.max(globalYMin, globalYMin + fallbackPad);
                    const fallbackEnd = Math.max(fallbackStart + 1, globalYMax - fallbackPad);
                    percentBase = fallbackStart;
                    percentRange = fallbackEnd - fallbackStart;
                    debugInfo.fallbackPad = fallbackPad;
                    debugInfo.start = percentBase;
                    debugInfo.end = fallbackEnd;
                }
            } else {
                debugInfo.start = percentBase;
                debugInfo.end = percentBase + percentRange;
            }

            debugInfo.percentBase = percentBase;
            debugInfo.percentRange = percentRange;
            console.log('[sequenceDiagram] Y baseline info', debugInfo);

            function resolveAbsolute(value, unit, fallback) {
                if (typeof value !== 'number') {
                    return fallback;
                }
                if (unit === 'percent') {
                    return percentBase + (value / 100) * percentRange;
                }
                return value;
            }

            function resolveDelta(value, unit) {
                if (typeof value !== 'number') {
                    return 0;
                }
                if (unit === 'percent') {
                    return (value / 100) * percentRange;
                }
                return value;
            }

            for (const token of Object.keys(mapObj)) {
                const info = mapObj[token];
                const labelEls = findLabelElements(svgEl, token);
                if (labelEls.length === 0) {
                    continue;
                }

                for (const labelEl of labelEls) {
                    let group = labelEl;
                    while (group && group.nodeName !== 'g' && group.nodeName !== 'svg') {
                        group = group.parentNode;
                    }
                    const parent = group && group.parentNode;
                    let candidates = parent ? Array.from(parent.querySelectorAll('path, line')) : [];
                    if (candidates.length === 0) {
                        candidates = allEdges.slice();
                    }

                    const labelBox = safeGetBBox(labelEl);
                    const labelCenter = {
                        x: labelBox.x + (labelBox.width || 0) / 2,
                        y: labelBox.y + (labelBox.height || 0) / 2
                    };

                    let bestEdge = null;
                    let bestDist = Infinity;
                    candidates.forEach(edge => {
                        try {
                            let center = { x: 0, y: 0 };
                            if (edge.tagName === 'line') {
                                const x1 = Number(edge.getAttribute('x1') || 0);
                                const y1 = Number(edge.getAttribute('y1') || 0);
                                const x2 = Number(edge.getAttribute('x2') || 0);
                                const y2 = Number(edge.getAttribute('y2') || 0);
                                center = {
                                    x: (x1 + x2) / 2,
                                    y: (y1 + y2) / 2
                                };
                            } else {
                                const dAttr = edge.getAttribute('d') || '';
                                const pts = extractEndpointsFromPathD(dAttr);
                                if (pts) {
                                    center = {
                                        x: (pts.x1 + pts.x2) / 2,
                                        y: (pts.y1 + pts.y2) / 2
                                    };
                                } else {
                                    const bb = edge.getBBox();
                                    center = {
                                        x: bb.x + bb.width / 2,
                                        y: bb.y + bb.height / 2
                                    };
                                }
                            }
                            const dx = center.x - labelCenter.x;
                            const dy = center.y - labelCenter.y;
                            const dist2 = dx * dx + dy * dy;
                            if (dist2 < bestDist) {
                                bestDist = dist2;
                                bestEdge = edge;
                            }
                        } catch (error) {
                            // Ignore malformed edge
                        }
                    });

                    if (!bestEdge) {
                        continue;
                    }

                    let x1;
                    let y1;
                    let x2;
                    let y2;
                    if (bestEdge.tagName === 'line') {
                        x1 = Number(bestEdge.getAttribute('x1') || 0);
                        y1 = Number(bestEdge.getAttribute('y1') || 0);
                        x2 = Number(bestEdge.getAttribute('x2') || 0);
                        y2 = Number(bestEdge.getAttribute('y2') || 0);
                    } else {
                        const dAttr = bestEdge.getAttribute('d') || '';
                        const pts = extractEndpointsFromPathD(dAttr);
                        if (!pts) {
                            continue;
                        }
                        x1 = pts.x1;
                        y1 = pts.y1;
                        x2 = pts.x2;
                        y2 = pts.y2;
                    }

                    let newY1 = y1;
                    let newY2 = y2;

                    if (typeof info.ys === 'number') {
                        newY1 = resolveAbsolute(info.ys, info.ysUnit, newY1);
                    } else if (typeof info.dys === 'number') {
                        newY1 = newY1 + resolveDelta(info.dys, info.dysUnit);
                    }

                    if (typeof info.ye === 'number') {
                        newY2 = resolveAbsolute(info.ye, info.yeUnit, newY2);
                    } else if (typeof info.dye === 'number') {
                        newY2 = newY2 + resolveDelta(info.dye, info.dyeUnit);
                    }

                    if (bestEdge.tagName === 'line') {
                        const newPathD = makeSmoothCubicPath(x1, newY1, x2, newY2);
                        const svgNS = 'http://www.w3.org/2000/svg';
                        const newPath = document.createElementNS(svgNS, 'path');
                        Array.from(bestEdge.attributes).forEach(attr => {
                            if (['x1', 'y1', 'x2', 'y2'].includes(attr.name)) {
                                return;
                            }
                            newPath.setAttribute(attr.name, attr.value);
                        });
                        newPath.setAttribute('d', newPathD);
                        bestEdge.parentNode.replaceChild(newPath, bestEdge);
                        bestEdge = newPath;
                    } else {
                        const newPathD = makeSmoothCubicPath(x1, newY1, x2, newY2);
                        bestEdge.setAttribute('d', newPathD);
                    }

                    if (labelEl.textContent && labelEl.textContent.includes(token)) {
                        const replacement = (info.orig || '').trim();
                        if (replacement) {
                            labelEl.textContent = replacement;
                        } else {
                            labelEl.textContent = labelEl.textContent.replace(token, '').trim();
                        }
                    }

                    const midX = (x1 + x2) / 2;
                    const midY = (newY1 + newY2) / 2;
                    let moveTarget = labelEl;
                    if (labelEl.tagName && labelEl.tagName.toLowerCase() === 'tspan') {
                        moveTarget = labelEl.parentNode;
                    }

                    try {
                        const lb = moveTarget.getBBox();
                        const currentCx = lb.x + lb.width / 2;
                        const currentCy = lb.y + lb.height / 2;
                        const dx = midX - currentCx;
                        const dy = midY - currentCy - 8;
                        const prevTransform = moveTarget.getAttribute('transform') || '';
                        moveTarget.setAttribute('transform', `${prevTransform} translate(${dx}, ${dy})`);
                    } catch (error) {
                        moveTarget.style.transform = `translate(${midX}px, ${midY - 8}px)`;
                    }
                }
            }
        }

        /**
         * Render sequence diagram using Mermaid.js
         * @param {string} containerId - Container element ID
         * @param {TransactionTimeline} timeline - Transaction timeline data
         */
        async function renderMermaidSequenceDiagram(containerId, timeline) {
            const container = document.getElementById(containerId);
            if (!container) {
                console.error(`Container ${containerId} not found`);
                return;
            }
            
            // Show loading state
            container.innerHTML = '<div class="sequence-diagram-loading">Generating sequence diagram...</div>';
            
            // Check if Mermaid is loaded
            if (typeof mermaid === 'undefined') {
                container.innerHTML = '<div class="sequence-diagram-error">Mermaid.js library not loaded</div>';
                return;
            }
            
            let mermaidCode = '';
            try {
                // Convert data to Mermaid syntax
                mermaidCode = convertTimelineToMermaid(timeline);
                
                // Initialize Mermaid (safe to call multiple times)
                mermaid.initialize({
                    startOnLoad: false,
                    theme: 'default',
                    sequence: {
                        diagramMarginX: 50,
                        diagramMarginY: 10,
                        actorMargin: 50,
                        width: 150,
                        height: 65,
                        boxMargin: 10,
                        boxTextMargin: 5,
                        noteMargin: 10,
                        messageMargin: 35,
                        mirrorActors: true,
                        bottomMarginAdj: 1,
                        useMaxWidth: true,
                        rightAngles: false,
                        showSequenceNumbers: false
                    }
                });
                
                // Create unique ID for this diagram
                const diagramId = `mermaid-diagram-${timeline.transactionID || Date.now()}`;
                
                const { text: processedCode, map } = preprocessMermaidDiagram(mermaidCode);
                const { svg } = await mermaid.render(diagramId, processedCode);

                const wrapper = document.createElement('div');
                wrapper.innerHTML = svg;
                const svgEl = wrapper.querySelector('svg');
                if (!svgEl) {
                    container.innerHTML = '<div class="sequence-diagram-error">Mermaid rendered empty diagram</div>';
                    return;
                }

                container.innerHTML = '';
                container.appendChild(svgEl);
                await postProcessMermaidSvg(svgEl, map);

                const sourceBlock = document.createElement('pre');
                sourceBlock.className = 'sequence-diagram-source';
                sourceBlock.textContent = mermaidCode;
                sourceBlock.style.marginTop = '12px';
                sourceBlock.style.padding = '8px 12px';
                sourceBlock.style.background = '#f7f7f7';
                sourceBlock.style.borderRadius = '6px';
                sourceBlock.style.fontSize = '11px';
                sourceBlock.style.lineHeight = '1.45';
                sourceBlock.style.whiteSpace = 'pre';
                sourceBlock.style.overflowX = 'auto';
                container.appendChild(sourceBlock);
                
            } catch (error) {
                console.error('Mermaid rendering error:', error);
                container.innerHTML = `<div class="sequence-diagram-error">Failed to render sequence diagram: ${error.message}<br><br>Mermaid Code:<br><pre style="font-size: 10px; overflow: auto;">${mermaidCode || 'N/A'}</pre></div>`;
            }
        }

        /**
         * Load and display transaction timeline
         */
        async function loadAndRenderTimeline(txnID) {
            const errorDiv = document.getElementById('timelineError');
            const container = document.getElementById('sequenceDiagramContainer');
            
            if (!txnID || txnID <= 0) {
                errorDiv.textContent = 'Please enter a valid transaction ID';
                errorDiv.classList.add('show');
                return;
            }
            
            errorDiv.classList.remove('show');
            errorDiv.textContent = '';
            
            // Show modal
            const modal = document.getElementById('sequenceDiagramModal');
            const title = document.getElementById('sequenceDiagramTitle');
            title.textContent = `Transaction Timeline - ID: ${txnID}`;
            modal.classList.add('show');
            
            // Show loading state
            container.innerHTML = '<div class="sequence-diagram-loading">Loading transaction timeline...</div>';
            
            try {
                const response = await fetch(`/api/transaction/${txnID}/timeline`);
                if (!response.ok) {
                    if (response.status === 404) {
                        throw new Error(`Transaction ${txnID} not found`);
                    }
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const timeline = await response.json();
                
                if (!timeline || !timeline.events || timeline.events.length === 0) {
                    container.innerHTML = '<div class="sequence-diagram-error">No events found for this transaction</div>';
                    return;
                }
                
                // Render the sequence diagram
                await renderMermaidSequenceDiagram('sequenceDiagramContainer', timeline);
                
            } catch (error) {
                console.error('Failed to load timeline:', error);
                container.innerHTML = `<div class="sequence-diagram-error">Failed to load transaction timeline: ${error.message}</div>`;
            }
        }

        // Event listeners for sequence diagram
        document.getElementById('btnLoadTimeline').addEventListener('click', async () => {
            const txnID = parseInt(document.getElementById('transactionID').value);
            await loadAndRenderTimeline(txnID);
        });

        document.getElementById('transactionID').addEventListener('keypress', async (e) => {
            if (e.key === 'Enter') {
                const txnID = parseInt(document.getElementById('transactionID').value);
                await loadAndRenderTimeline(txnID);
            }
        });

        // Close sequence diagram modal
        document.getElementById('sequenceDiagramClose').addEventListener('click', () => {
            document.getElementById('sequenceDiagramModal').classList.remove('show');
        });

        document.getElementById('sequenceDiagramModal').addEventListener('click', function(e) {
            if (e.target === this) {
                this.classList.remove('show');
            }
        });
    </script>
</body>
</html>

