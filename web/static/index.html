<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flow Control Simulator - Visualization</title>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/qtip2@3.0.3/dist/jquery.qtip.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/qtip2@3.0.3/dist/jquery.qtip.min.css">
    <script src="https://cdn.jsdelivr.net/npm/cytoscape@3.27.0/dist/cytoscape.min.js"></script>
    <script src="https://unpkg.com/cytoscape-qtip@2.8.0/cytoscape-qtip.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        .control-panel {
            width: 350px;
            background: #f5f5f5;
            border-right: 1px solid #ddd;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        .control-section {
            padding: 15px;
            border-bottom: 1px solid #ddd;
        }

        .control-section h3 {
            margin-bottom: 10px;
            color: #333;
            font-size: 14px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .control-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        button {
            padding: 8px 16px;
            border: 1px solid #ccc;
            background: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }

        button:hover:not(:disabled) {
            background: #f0f0f0;
            border-color: #999;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        button.primary {
            background: #007bff;
            color: white;
            border-color: #007bff;
        }

        button.primary:hover:not(:disabled) {
            background: #0056b3;
        }

        button.danger {
            background: #dc3545;
            color: white;
            border-color: #dc3545;
        }

        button.danger:hover:not(:disabled) {
            background: #c82333;
        }

        .status-info {
            font-size: 12px;
            color: #666;
            margin-top: 8px;
        }

        .status-info strong {
            color: #333;
        }

        .config-form {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .form-group label {
            font-size: 12px;
            color: #666;
            font-weight: 500;
        }

        .form-group input {
            padding: 6px 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 13px;
        }

        .form-group input:focus {
            outline: none;
            border-color: #007bff;
        }

        .form-row {
            display: flex;
            gap: 10px;
        }

        .form-row .form-group {
            flex: 1;
        }

        .stats-panel {
            max-height: 400px;
            overflow-y: auto;
        }

        .stats-item {
            padding: 8px;
            background: white;
            border-radius: 4px;
            margin-bottom: 8px;
            font-size: 12px;
        }

        .stats-item h4 {
            margin-bottom: 6px;
            color: #333;
            font-size: 13px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            margin-top: 6px;
        }

        .stats-value {
            color: #666;
        }

        .stats-value strong {
            color: #333;
        }

        .visualization-area {
            flex: 1;
            position: relative;
            background: #fff;
        }

        #cy {
            width: 100%;
            height: 100%;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 20px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            z-index: 1000;
        }

        .error-message {
            padding: 10px;
            background: #fee;
            border: 1px solid #fcc;
            border-radius: 4px;
            color: #c33;
            font-size: 12px;
            margin-top: 10px;
            display: none;
        }

        .error-message.show {
            display: block;
        }

        .queue-info {
            font-size: 11px;
            color: #666;
            margin-top: 4px;
        }

        /* Modal styles */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 10000;
            justify-content: center;
            align-items: center;
        }

        .modal-overlay.show {
            display: flex;
        }

        .modal-content {
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            max-width: 800px;
            max-height: 90vh;
            width: 90%;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .modal-header {
            padding: 20px;
            border-bottom: 1px solid #ddd;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #f5f5f5;
        }

        .modal-header h2 {
            margin: 0;
            font-size: 18px;
            color: #333;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #666;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
        }

        .modal-close:hover {
            background: #e0e0e0;
            color: #333;
        }

        .modal-body {
            padding: 20px;
            overflow-y: auto;
            flex: 1;
        }

        .queue-section {
            margin-bottom: 30px;
        }

        .queue-section h3 {
            font-size: 16px;
            color: #333;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 2px solid #007bff;
        }

        .queue-section.empty {
            color: #999;
            font-style: italic;
            padding: 20px;
            text-align: center;
        }

        .packet-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
            font-size: 13px;
        }

        .packet-table th {
            background: #f5f5f5;
            padding: 10px;
            text-align: left;
            border-bottom: 2px solid #ddd;
            font-weight: 600;
            color: #333;
        }

        .packet-table td {
            padding: 10px;
            border-bottom: 1px solid #eee;
        }

        .packet-table tr:hover {
            background: #f9f9f9;
        }

        .packet-id {
            font-weight: 600;
            color: #007bff;
        }

        .packet-field-label {
            font-weight: 500;
            color: #666;
            width: 150px;
        }

        .packet-field-value {
            color: #333;
        }

        /* Sequence diagram styles */
        .sequence-diagram-container {
            width: 100%;
            height: 600px;
            overflow: auto;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: #fff;
            padding: 20px;
        }

        .sequence-diagram-container .mermaid {
            text-align: center;
        }

        .sequence-diagram-loading {
            text-align: center;
            padding: 40px;
            color: #999;
        }

        .sequence-diagram-error {
            padding: 20px;
            background: #fee;
            border: 1px solid #fcc;
            border-radius: 4px;
            color: #c33;
        }

        .packet-item {
            margin-bottom: 20px;
            border: 1px solid #ddd;
            border-radius: 4px;
            overflow: hidden;
        }

        .packet-item-header {
            background: #f5f5f5;
            padding: 10px 15px;
            font-weight: 600;
            color: #333;
            border-bottom: 1px solid #ddd;
        }

        .packet-item-body {
            padding: 15px;
        }

        @media (max-width: 768px) {
            body {
                flex-direction: column;
            }

            .control-panel {
                width: 100%;
                max-height: 40vh;
            }
        }
    </style>
</head>
<body>
    <div class="control-panel">
        <div class="control-section">
            <h3>Simulation Control</h3>
            <div class="control-buttons">
                <button id="btnPause" class="primary">Pause</button>
                <button id="btnResume" class="primary">Resume</button>
                <button id="btnStep" class="primary">Step</button>
                <button id="btnReset" class="danger">Reset</button>
            </div>
            <div class="status-info">
                <div>Cycle: <strong id="currentCycle">-</strong></div>
                <div>In-Flight: <strong id="inFlightCount">-</strong></div>
                <div id="simStatus">Status: <strong>Waiting</strong></div>
            </div>
            <div id="errorMessage" class="error-message"></div>
        </div>

        <div class="control-section">
            <h3>Configuration</h3>
            <div class="config-form">
                <div class="form-group">
                    <label>Network Configuration</label>
                    <select id="networkConfig" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                        <option value="">Loading configurations...</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Total Cycles</label>
                    <input type="number" id="totalCycles" min="1" value="1000">
                </div>
            </div>
            <div class="status-info" style="margin-top: 10px; font-size: 11px; color: #999;">
                Select a predefined network configuration. Changes take effect after Reset.
            </div>
        </div>

        <div class="control-section">
            <h3>Statistics</h3>
            <div class="stats-panel" id="statsPanel">
                <div class="stats-item">
                    <div style="text-align: center; color: #999;">No data available</div>
                </div>
            </div>
        </div>

        <div class="control-section">
            <h3>Transaction Timeline</h3>
            <div class="form-group">
                <label>Transaction ID</label>
                <input type="number" id="transactionID" min="1" placeholder="Enter transaction ID" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
            </div>
            <button id="btnLoadTimeline" class="primary" style="width: 100%; margin-top: 8px;">Load Timeline</button>
            <div id="timelineError" class="error-message" style="margin-top: 8px;"></div>
        </div>
    </div>

    <div class="visualization-area">
        <div id="cy"></div>
        <svg id="pipelineOverlay" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10;"></svg>
        <div id="loading" class="loading" style="display: none;">
            <div>Loading simulation data...</div>
        </div>
    </div>

    <!-- Modal for displaying packet information -->
    <div id="packetModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modalTitle">Node Packet Information</h2>
                <button class="modal-close" id="modalClose">&times;</button>
            </div>
            <div class="modal-body" id="modalBody">
                <!-- Content will be populated by JavaScript -->
            </div>
        </div>
    </div>

    <!-- Modal for displaying sequence diagram -->
    <div id="sequenceDiagramModal" class="modal-overlay">
        <div class="modal-content" style="max-width: 1200px;">
            <div class="modal-header">
                <h2 id="sequenceDiagramTitle">Transaction Timeline</h2>
                <button class="modal-close" id="sequenceDiagramClose">&times;</button>
            </div>
            <div class="modal-body">
                <div id="sequenceDiagramContainer" class="sequence-diagram-container">
                    <div class="sequence-diagram-loading">Loading sequence diagram...</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let cy;
        let ws = null; // WebSocket connection
        let wsReconnectTimeout = null;
        let isPaused = true; // Web mode starts paused at cycle 0
        let currentFrame = null;
        let topologyInitialized = false;
        let currentConfigName = null; // Track current network configuration name
        let lastConfigHash = null; // Track last config hash from frame to detect config changes
        let expectingReset = false; // Track if we're waiting for a reset frame (cycle 0)
        let isStepProcessing = false; // Track if a step command is being processed

        // Calculate load percentage for a queue
        function calculateQueueLoad(queue) {
            if (!queue || queue.capacity === -1 || queue.capacity === 0) {
                return 0; // Unlimited capacity or invalid capacity
            }
            const load = Math.min(100, Math.max(0, (queue.length / queue.capacity) * 100));
            return load;
        }

        // Get color for load percentage
        function getLoadColor(percentage) {
            if (percentage < 50) {
                return '#52c41a'; // Green for low load
            } else if (percentage < 80) {
                return '#faad14'; // Yellow for medium load
            } else {
                return '#ff4d4f'; // Red for high load
            }
        }

        // Create progress bar SVG for multiple queues
        function createProgressBarsSVG(queues, nodeWidth, nodeHeight) {
            if (!queues || queues.length === 0) {
                return 'none';
            }

            const progressBarHeight = 3;
            const progressBarSpacing = 1;
            const totalProgressHeight = queues.length * progressBarHeight + (queues.length - 1) * progressBarSpacing;
            const padding = 2;
            const startY = nodeHeight - totalProgressHeight - padding;

            let svgParts = [];
            
            // Draw transparent background for the entire node (so the original background color shows through)
            svgParts.push(`<rect x="0" y="0" width="${nodeWidth}" height="${nodeHeight}" fill="transparent"/>`);
            
            queues.forEach((queue, index) => {
                const load = calculateQueueLoad(queue);
                const y = startY + index * (progressBarHeight + progressBarSpacing);
                const progressWidth = (load / 100) * nodeWidth;
                const color = getLoadColor(load);

                // Background bar (gray, semi-transparent)
                svgParts.push(`<rect x="0" y="${y}" width="${nodeWidth}" height="${progressBarHeight}" fill="#e0e0e0" opacity="0.6" rx="1"/>`);
                
                // Progress bar (colored)
                if (progressWidth > 0) {
                    svgParts.push(`<rect x="0" y="${y}" width="${progressWidth}" height="${progressBarHeight}" fill="${color}" rx="1"/>`);
                }
            });

            const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${nodeWidth}" height="${nodeHeight}">${svgParts.join('')}</svg>`;
            return 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svg);
        }

        // Custom layout: Master on left, Slave on right, Relay in center
        function applyCustomLayout() {
            if (!cy || cy.elements().length === 0) {
                return;
            }
            
            const containerWidth = cy.width();
            const containerHeight = cy.height();
            
            // Use default dimensions if container not ready
            if (containerWidth === 0 || containerHeight === 0) {
                return;
            }
            
            const leftX = containerWidth * 0.2;      // Master nodes on left
            const centerX = containerWidth * 0.5;   // Relay in center
            const rightX = containerWidth * 0.8;     // Slave nodes on right
            
            // Support both CHI node types (RN/HN/SN) and legacy types (master/slave/relay)
            const masters = cy.nodes('[type="RN"], [type="master"]');
            const slaves = cy.nodes('[type="SN"], [type="slave"]');
            const relays = cy.nodes('[type="HN"], [type="relay"]');
            
            // Layout Master nodes on left, vertically distributed
            if (masters.length > 0) {
                const masterSpacing = Math.min(containerHeight / Math.max(masters.length + 1, 2), 150);
                const totalHeight = (masters.length - 1) * masterSpacing;
                const startY = (containerHeight - totalHeight) / 2;
                masters.forEach((node, index) => {
                    node.position({
                        x: leftX,
                        y: startY + index * masterSpacing
                    });
                });
            }
            
            // Layout Relay node(s) in center
            if (relays.length > 0) {
                relays.forEach((node) => {
                    node.position({
                        x: centerX,
                        y: containerHeight / 2
                    });
                });
            }
            
            // Layout Slave nodes on right, vertically distributed
            if (slaves.length > 0) {
                const slaveSpacing = Math.min(containerHeight / Math.max(slaves.length + 1, 2), 150);
                const totalHeight = (slaves.length - 1) * slaveSpacing;
                const startY = (containerHeight - totalHeight) / 2;
                slaves.forEach((node, index) => {
                    node.position({
                        x: rightX,
                        y: startY + index * slaveSpacing
                    });
                });
            }
        }

        // Initialize Cytoscape
        function initCytoscape() {
            cy = cytoscape({
                container: document.getElementById('cy'),
                elements: [],
                style: [
                    {
                        selector: 'node',
                        style: {
                            'label': 'data(label)',
                            'width': '60px',
                            'height': 'data(height)',
                            'shape': 'round-rectangle',
                            'background-color': '#e8e8e8',
                            'background-image': 'data(progressBg)',
                            'background-width': '100%',
                            'background-height': '100%',
                            'background-fit': 'cover',
                            'background-position-x': '0%',
                            'background-position-y': '100%',
                            'border-width': 2,
                            'border-color': '#888',
                            'text-valign': 'center',
                            'text-halign': 'center',
                            'font-size': '12px',
                            'font-weight': 'bold',
                            'color': '#333',
                            'text-wrap': 'wrap',
                            'text-max-width': '80px'
                        }
                    },
                    {
                        selector: 'node[type="RN"], node[type="master"]',
                        style: {
                            'background-color': '#4a9eff',
                            'border-color': '#0066cc',
                            'color': 'white'
                        }
                    },
                    {
                        selector: 'node[type="SN"], node[type="slave"]',
                        style: {
                            'background-color': '#52c41a',
                            'border-color': '#389e0d',
                            'color': 'white'
                        }
                    },
                    {
                        selector: 'node[type="HN"], node[type="relay"]',
                        style: {
                            'background-color': '#ff7a45',
                            'border-color': '#d4380d',
                            'color': 'white'
                        }
                    },
                    {
                        selector: 'edge',
                        style: {
                            'width': 2,
                            'line-color': '#999',
                            'target-arrow-color': '#999',
                            'target-arrow-shape': 'triangle',
                            'curve-style': 'bezier',
                            'label': 'data(label)',
                            'font-size': '10px',
                            'text-rotation': 'autorotate',
                            'text-margin-y': -10
                        }
                    },
                    {
                        selector: 'edge[label="Req"], edge[label="request"]',
                        style: {
                            'line-color': '#4a9eff',
                            'target-arrow-color': '#4a9eff'
                        }
                    },
                    {
                        selector: 'edge[label="Comp"], edge[label="response"]',
                        style: {
                            'line-color': '#52c41a',
                            'target-arrow-color': '#52c41a'
                        }
                    },
                    {
                        selector: 'edge[label="forward"]',
                        style: {
                            'line-color': '#ff7a45',
                            'target-arrow-color': '#ff7a45'
                        }
                    },
                    {
                        selector: 'edge[label="return"]',
                        style: {
                            'line-color': '#faad14',
                            'target-arrow-color': '#faad14'
                        }
                    }
                ]
            });

            // Register cytoscape-qtip plugin if available
            if (typeof cyqtip === 'function') {
                cyqtip(cytoscape);
            }

            // Hide all active tooltips
            function hideAllTooltips() {
                $('.qtip').qtip('hide');
            }

            // Add hover tooltip for nodes
            cy.on('mouseover', 'node', function(evt) {
                const node = evt.target;
                const data = node.data();
                let tooltip = `${data.label}\nID: ${data.id}\nType: ${data.type}`;
                
                // Display CHI protocol information
                if (data.payload && data.payload.chiProtocol) {
                    const nodeTypeMap = {'RN': 'Request Node (CHI)', 'HN': 'Home Node (CHI)', 'SN': 'Slave Node (CHI)'};
                    const chiType = data.payload.nodeType || data.type;
                    tooltip += `\nCHI Protocol: ${nodeTypeMap[chiType] || chiType}`;
                }
                
                if (data.queues && data.queues.length > 0) {
                    tooltip += '\n\nQueues:';
                    data.queues.forEach(q => {
                        const cap = q.capacity === -1 ? '∞' : q.capacity;
                        tooltip += `\n${q.name}: ${q.length}/${cap}`;
                    });
                }

                if (data.payload) {
                    tooltip += '\n\nStats:';
                    for (const [key, value] of Object.entries(data.payload)) {
                        // Skip internal CHI protocol fields in tooltip
                        if (key === 'chiProtocol' || key === 'nodeType') continue;
                        if (typeof value === 'number') {
                            tooltip += `\n${key}: ${value.toFixed(2)}`;
                        } else {
                            tooltip += `\n${key}: ${value}`;
                        }
                    }
                }

                let api = node.qtip('api');
                if (!api) {
                    node.qtip({
                        content: {
                            text: tooltip
                        },
                        position: {
                            my: 'top center',
                            at: 'bottom center',
                            viewport: document.getElementById('cy'),
                            adjust: {
                                method: 'flip shift'
                            }
                        },
                        style: {
                            classes: 'qtip-bootstrap',
                            tip: {
                                width: 16,
                                height: 8
                            }
                        },
                        show: {
                            event: 'mouseover',
                            solo: true
                        },
                        hide: {
                            event: 'mouseout',
                            fixed: true,
                            delay: 200
                        }
                    });
                    api = node.qtip('api');
                }

                if (api && typeof api.set === 'function') {
                    api.set('content.text', tooltip);
                }
            });

            // Add click event for nodes to show packet information
            cy.on('tap', 'node', function(evt) {
                const node = evt.target;
                const data = node.data();
                showPacketModal(data);
            });

            // Add hover tooltip for edges to show pipeline stages
            cy.on('mouseover', 'edge', function(evt) {
                const edge = evt.target;
                const data = edge.data();
                let tooltip = `${data.label}\nSource: ${data.source} → Target: ${data.target}`;
                
                if (data.pipelineStages && data.pipelineStages.length > 0) {
                    tooltip += '\n\nPipeline Stages:';
                    data.pipelineStages.forEach(stage => {
                        tooltip += `\nStage ${stage.stageIndex}: ${stage.packetCount} packet(s)`;
                    });
                    
                    // Indicate potential backpressure if Slot[0] has packets
                    if (data.pipelineStages[0] && data.pipelineStages[0].packetCount > 0) {
                        tooltip += '\n\n⚠ Slot[0] has packets (may indicate backpressure)';
                    }
                } else {
                    tooltip += '\n\nNo pipeline data available';
                }

                let api = edge.qtip('api');
                if (!api) {
                    edge.qtip({
                        content: {
                            text: tooltip
                        },
                        position: {
                            my: 'top center',
                            at: 'bottom center',
                            viewport: document.getElementById('cy'),
                            adjust: {
                                method: 'flip shift'
                            }
                        },
                        style: {
                            classes: 'qtip-bootstrap',
                            tip: {
                                width: 16,
                                height: 8
                            }
                        },
                        show: {
                            event: 'mouseover',
                            solo: true
                        },
                        hide: {
                            event: 'mouseout',
                            fixed: true,
                            delay: 200
                        }
                    });
                    api = edge.qtip('api');
                }

                if (api && typeof api.set === 'function') {
                    api.set('content.text', tooltip);
                }
            });

            // Update pipeline state points when view changes (pan, zoom, render)
            cy.on('render', function() {
                if (currentFrame) {
                    drawPipelineStatePoints(currentFrame);
                }
            });
            
            // Recalculate points on pan (translation)
            cy.on('pan', function() {
                hideAllTooltips();
                if (currentFrame) {
                    drawPipelineStatePoints(currentFrame);
                }
            });
            
            // Recalculate points on zoom
            cy.on('zoom', function() {
                hideAllTooltips();
                if (currentFrame) {
                    drawPipelineStatePoints(currentFrame);
                }
            });
            
            // Recalculate points on panzoom (combined pan and zoom)
            cy.on('panzoom', function() {
                hideAllTooltips();
                if (currentFrame) {
                    drawPipelineStatePoints(currentFrame);
                }
            });
        }

        // Format CHI protocol field values for display
        function formatCHIField(field, value) {
            if (value === undefined || value === null || value === '') {
                return 'N/A';
            }
            
            if (field === 'transactionType') {
                const typeMap = {
                    'ReadNoSnp': 'ReadNoSnp',
                    'WriteNoSnp': 'WriteNoSnp',
                    'ReadOnce': 'ReadOnce',
                    'WriteUnique': 'WriteUnique'
                };
                return typeMap[value] || value;
            }
            
            if (field === 'messageType') {
                const typeMap = {
                    'Req': 'Request',
                    'Resp': 'Response',
                    'Data': 'Data',
                    'Comp': 'Completion'
                };
                return typeMap[value] || value;
            }
            
            if (field === 'responseType') {
                const typeMap = {
                    'CompData': 'CompData (Completion with Data)',
                    'CompAck': 'CompAck (Completion Acknowledgment)'
                };
                return typeMap[value] || value;
            }
            
            if (field === 'address') {
                return '0x' + value.toString(16).toUpperCase().padStart(16, '0');
            }
            
            if (field === 'type') {
                return value.charAt(0).toUpperCase() + value.slice(1);
            }
            
            return value;
        }

        // Format packet information for display
        function formatPacketInfo(packet) {
            const fields = [
                { label: 'Packet ID', key: 'id', format: (v) => v },
                { label: 'Type', key: 'type', format: (v) => formatCHIField('type', v) },
                { label: 'Source Node ID', key: 'srcID', format: (v) => v !== undefined ? v : 'N/A' },
                { label: 'Destination Node ID', key: 'dstID', format: (v) => v !== undefined ? v : 'N/A' },
                { label: 'Master ID', key: 'masterID', format: (v) => v !== undefined ? v : 'N/A' },
                { label: 'Request ID', key: 'requestID', format: (v) => v !== undefined ? v : 'N/A' },
                { label: 'Transaction Type', key: 'transactionType', format: (v) => formatCHIField('transactionType', v) },
                { label: 'Message Type', key: 'messageType', format: (v) => formatCHIField('messageType', v) },
                { label: 'Response Type', key: 'responseType', format: (v) => formatCHIField('responseType', v) },
                { label: 'Address', key: 'address', format: (v) => v !== undefined ? formatCHIField('address', v) : 'N/A' },
                { label: 'Data Size (bytes)', key: 'dataSize', format: (v) => v !== undefined ? v : 'N/A' },
                { label: 'Generated At (cycle)', key: 'generatedAt', format: (v) => v !== undefined && v !== 0 ? v : 'N/A' },
                { label: 'Sent At (cycle)', key: 'sentAt', format: (v) => v !== undefined && v !== 0 ? v : 'N/A' },
                { label: 'Received At (cycle)', key: 'receivedAt', format: (v) => v !== undefined && v !== 0 ? v : 'N/A' },
                { label: 'Completed At (cycle)', key: 'completedAt', format: (v) => v !== undefined && v !== 0 ? v : 'N/A' }
            ];
            
            let html = '<table class="packet-table">';
            fields.forEach(field => {
                const value = packet[field.key];
                if (value !== undefined && value !== null && value !== '') {
                    html += `<tr><td class="packet-field-label">${field.label}:</td><td class="packet-field-value">${field.format(value)}</td></tr>`;
                }
            });
            html += '</table>';
            return html;
        }

        // Show packet modal with node information
        function showPacketModal(nodeData) {
            const modal = document.getElementById('packetModal');
            const modalTitle = document.getElementById('modalTitle');
            const modalBody = document.getElementById('modalBody');
            
            modalTitle.textContent = `${nodeData.label || 'Node'} - Packet Information`;
            
            let html = '';
            
            if (!nodeData.queues || nodeData.queues.length === 0) {
                html = '<div class="queue-section empty">No queues found for this node.</div>';
            } else {
                nodeData.queues.forEach(queue => {
                    html += `<div class="queue-section">`;
                    html += `<h3>${queue.name} (${queue.length}/${queue.capacity === -1 ? '∞' : queue.capacity})</h3>`;
                    
                    if (!queue.packets || queue.packets.length === 0) {
                        html += '<div class="empty">This queue is empty.</div>';
                    } else {
                        queue.packets.forEach((packet, index) => {
                            html += `<div class="packet-item">`;
                            html += `<div class="packet-item-header">Packet #${index + 1} (ID: <span class="packet-id">${packet.id}</span>)</div>`;
                            html += `<div class="packet-item-body">`;
                            html += formatPacketInfo(packet);
                            html += `</div></div>`;
                        });
                    }
                    
                    html += `</div>`;
                });
            }
            
            modalBody.innerHTML = html;
            modal.classList.add('show');
        }

        // Close modal
        function closePacketModal() {
            const modal = document.getElementById('packetModal');
            modal.classList.remove('show');
        }

        // Draw pipeline state points on edges using Cytoscape's midpoint API
        function drawPipelineStatePoints(frame) {
            const overlay = document.getElementById('pipelineOverlay');
            if (!overlay) {
                return;
            }

            // Clear existing points first, before any validation
            overlay.innerHTML = '';

            if (!frame || !frame.edges || !cy) {
                return;
            }

            // Get container position for coordinate conversion
            const container = document.getElementById('cy');
            const containerRect = container.getBoundingClientRect();

            frame.edges.forEach(edge => {
                const edgeId = `e${edge.source}-${edge.target}`;
                const cyEdge = cy.getElementById(edgeId);
                
                if (cyEdge.length === 0) {
                    return;
                }

                // Get the first edge element from the collection
                const cyEdgeElement = cyEdge[0];

                // Get data from both frame edge and Cytoscape edge (Cytoscape edge has the latest data)
                const edgeData = cyEdgeElement.data();
                const latency = edgeData.latency || edge.latency || 1;
                const bandwidthLimit = edgeData.bandwidthLimit || edge.bandwidthLimit || 1;
                const pipelineStages = edgeData.pipelineStages || edge.pipelineStages || [];

                // Validate values before drawing
                if (!latency || latency <= 0 || !isFinite(latency)) {
                    return;
                }
                if (!bandwidthLimit || bandwidthLimit <= 0 || !isFinite(bandwidthLimit)) {
                    return;
                }

                // Draw points using Cytoscape's midpoint API
                drawPointsOnEdge(cyEdgeElement, edge, latency, bandwidthLimit, pipelineStages, overlay);
            });

            // Update SVG size to match container
            overlay.setAttribute('width', containerRect.width);
            overlay.setAttribute('height', containerRect.height);
        }

        // Draw pipeline state points on a single edge using Cytoscape's midpoint API
        // Implementation: Use Cytoscape's midpoint() API + linear interpolation
        // This avoids manual Bezier curve calculation and ensures coordinate alignment
        function drawPointsOnEdge(cyEdge, edge, latency, bandwidthLimit, pipelineStages, overlay) {
            const container = document.getElementById('cy');
            if (!container) {
                return;
            }
            const containerRect = container.getBoundingClientRect();

            // Validate input parameters
            if (!latency || latency <= 0 || !isFinite(latency)) {
                return;
            }
            if (!bandwidthLimit || bandwidthLimit <= 0 || !isFinite(bandwidthLimit)) {
                return;
            }

            // Create a mapping of stageIndex to PacketCount
            const stageMap = {};
            if (pipelineStages && Array.isArray(pipelineStages)) {
                pipelineStages.forEach(stage => {
                    if (stage && typeof stage.stageIndex === 'number' && typeof stage.packetCount === 'number') {
                        stageMap[stage.stageIndex] = stage.packetCount;
                    }
                });
            }

            // Get source and target nodes
            const sourceNode = cyEdge.source();
            const targetNode = cyEdge.target();
            
            if (!sourceNode || !targetNode || sourceNode.length === 0 || targetNode.length === 0) {
                console.warn('Edge source or target node not found');
                return;
            }

            // Get source and target endpoint positions using renderedPosition()
            // renderedPosition() returns coordinates relative to the Cytoscape container
            // which matches the SVG overlay coordinate system
            let sourcePos, targetPos;
            
            try {
                // Use renderedPosition() which already accounts for zoom and pan
                // and returns coordinates relative to the container
                sourcePos = sourceNode.renderedPosition();
                targetPos = targetNode.renderedPosition();
                
                // Validate positions
                if (!sourcePos || !targetPos ||
                    !isFinite(sourcePos.x) || !isFinite(sourcePos.y) ||
                    !isFinite(targetPos.x) || !isFinite(targetPos.y)) {
                    throw new Error('renderedPosition() returned invalid values');
                }
            } catch (e) {
                console.warn('Failed to get edge positions using renderedPosition():', e);
                // Fallback: try position() and convert manually
                try {
                    const srcModelPos = sourceNode.position();
                    const tgtModelPos = targetNode.position();
                    const zoom = cy.zoom();
                    const pan = cy.pan();
                    
                    if (isFinite(srcModelPos.x) && isFinite(srcModelPos.y) &&
                        isFinite(tgtModelPos.x) && isFinite(tgtModelPos.y)) {
                        sourcePos = {
                            x: srcModelPos.x * zoom + pan.x,
                            y: srcModelPos.y * zoom + pan.y
                        };
                        targetPos = {
                            x: tgtModelPos.x * zoom + pan.x,
                            y: tgtModelPos.y * zoom + pan.y
                        };
                    } else {
                        throw new Error('position() also returned invalid values');
                    }
                } catch (e2) {
                    console.warn('All methods failed to get edge positions:', e2);
                    return;
                }
            }

            // Get midpoint using Cytoscape's midpoint() API
            // IMPORTANT: midpoint() returns MODEL coordinates, not rendered coordinates
            // We need to convert them to rendered coordinates using zoom and pan
            let midPoint;
            try {
                // Get midpoint in model coordinates
                const midPointModel = cyEdge.midpoint();
                
                // Validate model midpoint
                if (midPointModel && isFinite(midPointModel.x) && isFinite(midPointModel.y)) {
                    // Convert model coordinates to rendered coordinates
                    const zoom = cy.zoom();
                    const pan = cy.pan();
                    midPoint = {
                        x: midPointModel.x * zoom + pan.x,
                        y: midPointModel.y * zoom + pan.y
                    };
                } else {
                    // Fallback: calculate from rendered source and target positions
                    midPoint = {
                        x: (sourcePos.x + targetPos.x) / 2,
                        y: (sourcePos.y + targetPos.y) / 2
                    };
                }
            } catch (e) {
                // Fallback: calculate midpoint manually from rendered positions
                midPoint = {
                    x: (sourcePos.x + targetPos.x) / 2,
                    y: (sourcePos.y + targetPos.y) / 2
                };
            }
            
            // Final validation
            if (!isFinite(midPoint.x) || !isFinite(midPoint.y)) {
                console.warn('Failed to get valid midpoint');
                return;
            }

            // Draw points for each stage using linear interpolation
            // Interpolate between source, midpoint, and target to approximate curve position
            for (let stageIdx = 0; stageIdx < latency; stageIdx++) {
                // Calculate position ratio along the edge
                // Slot[0] (first stage, ready to arrive) should be near target
                // Slot[latency-1] (last stage, entry point) near source
                let ratio;
                if (latency === 1) {
                    ratio = 0.5; // Single stage at midpoint
                } else {
                    // Distribute points from 40% to 60% of the edge to avoid node overlap
                    // Map stageIdx from [0, latency-1] to [0.6, 0.4] (reversed)
                    ratio = 0.6 - (stageIdx / (latency - 1)) * 0.2;
                }

                // Linear interpolation between source, midpoint, and target
                // This approximates the curve position for better alignment
                let pointX, pointY;
                if (ratio <= 0.5) {
                    // Between source and midpoint
                    const t = ratio * 2; // Map [0, 0.5] to [0, 1]
                    pointX = sourcePos.x + (midPoint.x - sourcePos.x) * t;
                    pointY = sourcePos.y + (midPoint.y - sourcePos.y) * t;
                } else {
                    // Between midpoint and target
                    const t = (ratio - 0.5) * 2; // Map [0.5, 1] to [0, 1]
                    pointX = midPoint.x + (targetPos.x - midPoint.x) * t;
                    pointY = midPoint.y + (targetPos.y - midPoint.y) * t;
                }

                // Calculate perpendicular direction at the interpolated point
                // For linear interpolation, use the local direction vector
                // This is the direction from the previous point to the next point along the edge
                let dirX, dirY;
                if (ratio <= 0.5) {
                    // Direction from source to midpoint
                    dirX = midPoint.x - sourcePos.x;
                    dirY = midPoint.y - sourcePos.y;
                } else {
                    // Direction from midpoint to target
                    dirX = targetPos.x - midPoint.x;
                    dirY = targetPos.y - midPoint.y;
                }
                
                const length = Math.sqrt(dirX * dirX + dirY * dirY);
                let perpDir = { x: 0, y: 1 }; // Default vertical
                if (length > 0) {
                    // Perpendicular vector (rotated 90 degrees clockwise)
                    perpDir = {
                        x: dirY / length,
                        y: -dirX / length
                    };
                }

                const packetCount = stageMap[stageIdx] || 0;
                const pointSpacing = 4;
                const totalWidth = (bandwidthLimit - 1) * pointSpacing;
                const startOffset = -totalWidth / 2;

                // Validate interpolated point position
                if (!isFinite(pointX) || !isFinite(pointY)) {
                    console.warn(`Invalid point position for stage ${stageIdx}:`, { pointX, pointY });
                    continue;
                }

                // Draw points for this stage
                for (let i = 0; i < bandwidthLimit; i++) {
                    const offsetX = startOffset + i * pointSpacing;
                    const finalX = pointX + perpDir.x * offsetX;
                    const finalY = pointY + perpDir.y * offsetX;

                    // Validate final coordinates before drawing
                    if (!isFinite(finalX) || !isFinite(finalY)) {
                        console.warn(`Invalid final coordinates for stage ${stageIdx}, point ${i}:`, { finalX, finalY });
                        continue;
                    }

                    const isFilled = i < packetCount;
                    const color = isFilled ? '#ff4d4f' : '#999';
                    const radius = 3;

                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('cx', finalX);
                    circle.setAttribute('cy', finalY);
                    circle.setAttribute('r', radius);
                    circle.setAttribute('fill', color);
                    circle.setAttribute('stroke', '#fff');
                    circle.setAttribute('stroke-width', '0.5');
                    overlay.appendChild(circle);
                }
            }
        }

        // Fetch frame data from API
        async function fetchFrame() {
            try {
                const response = await fetch('/api/frame');
                if (!response.ok) {
                    if (response.status === 404) {
                        return null; // No frame available yet
                    }
                    throw new Error(`HTTP ${response.status}`);
                }
                const frame = await response.json();
                return frame;
            } catch (error) {
                console.error('Error fetching frame:', error);
                showError('Failed to fetch simulation data: ' + error.message);
                return null;
            }
        }

        // Update visualization with frame data
        function updateVisualization(frame) {
            if (!frame || !frame.nodes || !frame.edges) {
                return;
            }

            currentFrame = frame;

            // Check for config change using configHash from frame
            const configHash = frame.configHash || null;
            let shouldReinitialize = false;

            if (expectingReset && frame.cycle === 0) {
                // This is the reset frame we were waiting for
                shouldReinitialize = true;
                expectingReset = false;
                console.log('[DEBUG] Received reset frame (cycle 0), reinitializing topology');
            } else if (configHash && lastConfigHash !== null && configHash !== lastConfigHash) {
                // Config hash changed, network structure has changed
                shouldReinitialize = true;
                console.log('[DEBUG] Config hash changed:', lastConfigHash, '->', configHash, ', reinitializing topology');
            } else if (lastConfigHash === null && configHash) {
                // First frame with config hash, initialize it
                lastConfigHash = configHash;
            }

            if (shouldReinitialize) {
                cy.elements().remove();
                topologyInitialized = false;
                // Update lastConfigHash if configHash is available
                if (configHash) {
                    lastConfigHash = configHash;
                }
            }

            // Update status info
            document.getElementById('currentCycle').textContent = frame.cycle || 0;
            document.getElementById('inFlightCount').textContent = frame.inFlightCount || 0;
            
            const statusEl = document.getElementById('simStatus');
            if (frame.cycle >= (frame.totalCycles || 1000)) {
                statusEl.innerHTML = 'Status: <strong style="color: #52c41a;">Completed</strong>';
            } else {
                statusEl.innerHTML = 'Status: <strong style="color: #1890ff;">Running</strong>';
            }

            // Update button states based on current pause status
            updateButtonStates();

            // Initialize topology on first frame or after config change
            if (!topologyInitialized) {
                const elements = [];

                // Add nodes
                frame.nodes.forEach(node => {
                    const queues = node.queues || [];
                    const nodeWidth = 60;
                    const baseHeight = 60;
                    const progressBarHeight = queues.length > 0 ? queues.length * 3 + (queues.length - 1) * 1 + 4 : 0;
                    const nodeHeight = baseHeight + progressBarHeight;
                    
                    const progressBg = createProgressBarsSVG(queues, nodeWidth, nodeHeight);
                    
                    const nodeData = {
                        group: 'nodes',
                        data: {
                            id: String(node.id),
                            label: node.label || `Node ${node.id}`,
                            type: node.type,
                            queues: queues,
                            payload: node.payload || {},
                            height: nodeHeight,
                            progressBg: progressBg
                        }
                    };
                    elements.push(nodeData);
                });

                // Add edges
                frame.edges.forEach(edge => {
                    const edgeLabel = `${edge.label} (${edge.latency}cy)`;
                    const pipelineStages = edge.pipelineStages || [];
                    elements.push({
                        group: 'edges',
                        data: {
                            id: `e${edge.source}-${edge.target}`,
                            source: String(edge.source),
                            target: String(edge.target),
                            label: edgeLabel,
                            latency: edge.latency,
                            pipelineStages: pipelineStages,
                            bandwidthLimit: edge.bandwidthLimit
                        }
                    });
                });

                // Add all elements
                cy.add(elements);
                
                // Apply custom layout after elements are added
                // Use setTimeout to ensure Cytoscape has processed the elements
                setTimeout(() => {
                    applyCustomLayout();
                }, 50);
                
                topologyInitialized = true;
                // Update current config name after topology is initialized
                const newConfigName = getConfigFromForm();
                currentConfigName = newConfigName;
                // Update lastConfigHash if we have it from frame
                if (frame.configHash) {
                    lastConfigHash = frame.configHash;
                }
            }

            // Update existing nodes with new data (without re-layout)
            frame.nodes.forEach(node => {
                const nodeId = String(node.id);
                const cyNode = cy.getElementById(nodeId);
                
                if (cyNode.length > 0) {
                    const queues = node.queues || [];
                    const nodeWidth = 60;
                    const baseHeight = 60;
                    const progressBarHeight = queues.length > 0 ? queues.length * 3 + (queues.length - 1) * 1 + 4 : 0;
                    const nodeHeight = baseHeight + progressBarHeight;
                    
                    const progressBg = createProgressBarsSVG(queues, nodeWidth, nodeHeight);
                    
                    // Update node data
                    let label = node.label || `Node ${node.id}`;
                    if (queues.length > 0) {
                        const queueInfo = queues.map(q => {
                            const cap = q.capacity === -1 ? '∞' : q.capacity;
                            return `${q.name}:${q.length}/${cap}`;
                        }).join(' ');
                        label += `\n${queueInfo}`;
                    }

                    cyNode.data({
                        label: label,
                        queues: queues,
                        payload: node.payload || {},
                        height: nodeHeight,
                        progressBg: progressBg
                    });
                }
            });

            // Update existing edges with pipeline stages
            frame.edges.forEach(edge => {
                const edgeId = `e${edge.source}-${edge.target}`;
                const cyEdge = cy.getElementById(edgeId);
                
                if (cyEdge.length > 0) {
                    const pipelineStages = edge.pipelineStages || [];
                    let edgeLabel = `${edge.label} (${edge.latency}cy)`;
                    
                    cyEdge.data({
                        label: edgeLabel,
                        pipelineStages: pipelineStages,
                        bandwidthLimit: edge.bandwidthLimit
                    });
                    
                    // Update edge style based on backpressure (Slot[0] has packets but can't advance)
                    if (pipelineStages.length > 0 && pipelineStages[0].packetCount > 0) {
                        // Check if this indicates backpressure (would need receiver state, simplified here)
                        cyEdge.style('line-color', '#ff4d4f'); // Red for potential backpressure
                        cyEdge.style('width', 3);
                    } else {
                        cyEdge.style('line-color', '#91d5ff'); // Blue for normal
                        cyEdge.style('width', 2);
                    }
                }
            });

            // Draw pipeline state points
            drawPipelineStatePoints(frame);

            // Update statistics
            updateStatistics(frame.stats);
        }

        // Update statistics panel
        function updateStatistics(stats) {
            const panel = document.getElementById('statsPanel');
            if (!stats || !stats.Global) {
                panel.innerHTML = '<div class="stats-item"><div style="text-align: center; color: #999;">No data available</div></div>';
                return;
            }

            let html = '';

            // Global stats
            html += '<div class="stats-item">';
            html += '<h4>Global Statistics</h4>';
            html += '<div class="stats-grid">';
            html += `<div class="stats-value">Total Requests: <strong>${stats.Global.TotalRequests}</strong></div>`;
            html += `<div class="stats-value">Completed: <strong>${stats.Global.Completed}</strong></div>`;
            html += `<div class="stats-value">Completion Rate: <strong>${stats.Global.CompletionRate.toFixed(2)}%</strong></div>`;
            html += `<div class="stats-value">Avg Delay: <strong>${stats.Global.AvgEndToEndDelay.toFixed(2)} cy</strong></div>`;
            html += `<div class="stats-value">Max Delay: <strong>${stats.Global.MaxDelay} cy</strong></div>`;
            html += `<div class="stats-value">Min Delay: <strong>${stats.Global.MinDelay} cy</strong></div>`;
            html += '</div>';
            html += '</div>';

            // Master stats
            if (stats.PerMaster && stats.PerMaster.length > 0) {
                html += '<div class="stats-item">';
                html += '<h4>Master Statistics</h4>';
                stats.PerMaster.forEach((m, idx) => {
                    if (m) {
                        html += `<div style="margin-top: 6px; padding-top: 6px; border-top: 1px solid #eee;">`;
                        html += `<strong>Master ${idx}</strong><br>`;
                        html += `Completed: ${m.CompletedRequests}, `;
                        html += `Avg Delay: ${m.AvgDelay.toFixed(2)} cy, `;
                        html += `Max: ${m.MaxDelay} cy, Min: ${m.MinDelay} cy`;
                        html += '</div>';
                    }
                });
                html += '</div>';
            }

            // Slave stats
            if (stats.PerSlave && stats.PerSlave.length > 0) {
                html += '<div class="stats-item">';
                html += '<h4>Slave Statistics</h4>';
                stats.PerSlave.forEach((s, idx) => {
                    if (s) {
                        html += `<div style="margin-top: 6px; padding-top: 6px; border-top: 1px solid #eee;">`;
                        html += `<strong>Slave ${idx}</strong><br>`;
                        html += `Processed: ${s.TotalProcessed}, `;
                        html += `Max Queue: ${s.MaxQueueLength}, `;
                        html += `Avg Queue: ${s.AvgQueueLength.toFixed(2)}`;
                        html += '</div>';
                    }
                });
                html += '</div>';
            }

            panel.innerHTML = html;
        }

        // Send control command (prefer WebSocket, fallback to HTTP)
        async function sendControl(type, configName, totalCycles) {
            const body = { type: type };
            if (configName) {
                body.configName = configName;
            }
            if (totalCycles !== undefined && totalCycles !== null) {
                body.totalCycles = totalCycles;
            }

            // Try WebSocket first if connected
            if (ws && ws.readyState === WebSocket.OPEN) {
                try {
                    ws.send(JSON.stringify(body));
                    hideError();
                    return true;
                } catch (error) {
                    console.warn('[WebSocket] Failed to send via WebSocket, falling back to HTTP:', error);
                }
            }

            // Fallback to HTTP
            try {
                const response = await fetch('/api/control', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(body)
                });

                if (!response.ok) {
                    const text = await response.text();
                    throw new Error(text || `HTTP ${response.status}`);
                }

                hideError();
                return true;
            } catch (error) {
                console.error('Error sending control:', error);
                showError('Failed to send command: ' + error.message);
                return false;
            }
        }

        // Load available network configurations
        async function loadConfigurations() {
            try {
                const response = await fetch('/api/configs');
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                const configs = await response.json();
                
                const select = document.getElementById('networkConfig');
                select.innerHTML = '';
                
                if (configs.length === 0) {
                    select.innerHTML = '<option value="">No configurations available</option>';
                    return;
                }
                
                configs.forEach((cfg, index) => {
                    const option = document.createElement('option');
                    option.value = cfg.name;
                    option.textContent = cfg.description;
                    if (index === 0) {
                        option.selected = true;
                    }
                    select.appendChild(option);
                });
            } catch (error) {
                console.error('Error loading configurations:', error);
                const select = document.getElementById('networkConfig');
                select.innerHTML = '<option value="">Error loading configurations</option>';
                showError('Failed to load network configurations: ' + error.message);
            }
        }

        // Get selected configuration name from form
        function getConfigFromForm() {
            const select = document.getElementById('networkConfig');
            return select.value;
        }

        // Validate configuration
        function validateConfig(configName) {
            if (!configName) {
                return 'Please select a network configuration';
            }
            const totalCycles = parseInt(document.getElementById('totalCycles').value);
            if (isNaN(totalCycles) || totalCycles <= 0) {
                return 'TotalCycles must be a positive number';
            }
            return null;
        }

        // Show error message
        function showError(message) {
            const errorEl = document.getElementById('errorMessage');
            errorEl.textContent = message;
            errorEl.classList.add('show');
        }

        // Hide error message
        function hideError() {
            const errorEl = document.getElementById('errorMessage');
            errorEl.classList.remove('show');
        }

        // Fetch frame immediately (used after step commands)
        async function fetchFrameImmediate() {
            const frame = await fetchFrame();
            if (frame) {
                updateVisualization(frame);
            }
            return frame;
        }

        // Connect to WebSocket for real-time updates
        function connectWebSocket() {
            // Close existing connection if any
            if (ws) {
                ws.close();
                ws = null;
            }

            // Clear any pending reconnect
            if (wsReconnectTimeout) {
                clearTimeout(wsReconnectTimeout);
                wsReconnectTimeout = null;
            }

            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws`;
            
            try {
                ws = new WebSocket(wsUrl);

                ws.onopen = () => {
                    console.log('[WebSocket] Connected');
                    hideError();
                };

                ws.onmessage = (event) => {
                    try {
                        const frame = JSON.parse(event.data);
                        if (frame) {
                            updateVisualization(frame);
                        }
                    } catch (error) {
                        console.error('[WebSocket] Error parsing frame:', error);
                    }
                };

                ws.onerror = (error) => {
                    console.error('[WebSocket] Error:', error);
                    showError('WebSocket connection error. Please refresh the page to reconnect.');
                };

                ws.onclose = () => {
                    console.log('[WebSocket] Disconnected');
                    ws = null;
                    // Attempt to reconnect after 2 seconds
                    wsReconnectTimeout = setTimeout(() => {
                        console.log('[WebSocket] Attempting to reconnect...');
                        connectWebSocket();
                    }, 2000);
                };
            } catch (error) {
                console.error('[WebSocket] Failed to connect:', error);
                showError('WebSocket connection failed. Please refresh the page to reconnect.');
            }
        }

        // Disconnect WebSocket
        function disconnectWebSocket() {
            if (wsReconnectTimeout) {
                clearTimeout(wsReconnectTimeout);
                wsReconnectTimeout = null;
            }
            if (ws) {
                ws.close();
                ws = null;
            }
        }

        // Update button states based on pause status
        function updateButtonStates() {
            const btnPause = document.getElementById('btnPause');
            const btnResume = document.getElementById('btnResume');
            const btnStep = document.getElementById('btnStep');
            
            if (btnPause) {
                btnPause.disabled = isPaused; // Disable when paused
            }
            if (btnResume) {
                btnResume.disabled = !isPaused; // Disable when running
            }
            if (btnStep) {
                // Disable step button if not paused or if a step is being processed
                btnStep.disabled = !isPaused || isStepProcessing;
            }
        }

        // Event listeners
        document.getElementById('btnPause').addEventListener('click', async () => {
            const success = await sendControl('pause');
            if (success) {
                isPaused = true;
                updateButtonStates();
            }
        });

        document.getElementById('btnResume').addEventListener('click', async () => {
            const success = await sendControl('resume');
            if (success) {
                isPaused = false;
                updateButtonStates();
            }
        });

        document.getElementById('btnStep').addEventListener('click', async () => {
            if (!isPaused || isStepProcessing) {
                return; // Step button should only work when paused and not processing
            }
            
            // Set processing flag to prevent duplicate clicks
            isStepProcessing = true;
            updateButtonStates();
            
            try {
                const success = await sendControl('step');
                if (success) {
                    // Step command sent, immediately fetch frame to get updated state
                    // Wait a short time for simulator to process the step
                    await new Promise(resolve => setTimeout(resolve, 100));
                    
                    // Try to fetch frame multiple times with short delays to ensure we get the update
                    let frame = null;
                    for (let i = 0; i < 5; i++) {
                        frame = await fetchFrameImmediate();
                        if (frame) {
                            break;
                        }
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }
                }
            } finally {
                // Reset processing flag after a delay to allow for visual feedback
                setTimeout(() => {
                    isStepProcessing = false;
                    updateButtonStates();
                }, 200);
            }
        });

        document.getElementById('btnReset').addEventListener('click', async () => {
            const configName = getConfigFromForm();
            const error = validateConfig(configName);
            if (error) {
                showError(error);
                return;
            }
            const totalCycles = parseInt(document.getElementById('totalCycles').value);
            const success = await sendControl('reset', configName, totalCycles);
            if (success) {
                isPaused = true; // Reset pauses at cycle 0
                updateButtonStates();
                // Clear visualization and reset topology
                cy.elements().remove();
                topologyInitialized = false;
                // Update current config name to track the new configuration
                currentConfigName = configName;
                // Set flag to wait for reset frame (cycle 0)
                expectingReset = true;
                console.log('[DEBUG] Reset clicked, waiting for cycle 0 frame');
                document.getElementById('currentCycle').textContent = '-';
                document.getElementById('inFlightCount').textContent = '-';
                document.getElementById('simStatus').innerHTML = 'Status: <strong>Resetting...</strong>';
            }
        });

        // Initialize
        loadConfigurations();
        initCytoscape();
        updateButtonStates(); // Set initial button states (paused at cycle 0)
        connectWebSocket(); // Connect to WebSocket for real-time updates

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            disconnectWebSocket();
        });

        // Modal close event listeners (initialize after DOM is ready)
        document.getElementById('modalClose').addEventListener('click', closePacketModal);
        document.getElementById('packetModal').addEventListener('click', function(e) {
            if (e.target === this) {
                closePacketModal();
            }
        });

        // Reapply layout on window resize
        let resizeTimeout;
        window.addEventListener('resize', () => {
            if (topologyInitialized) {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    applyCustomLayout();
                }, 250);
            }
        });

        // Initial frame fetch
        fetchFrame().then(frame => {
            if (frame) {
                updateVisualization(frame);
            }
        });

        // ===== Mermaid Sequence Diagram Functions =====

        /**
         * Convert node label to Mermaid-compatible alias
         */
        function sanitizeAlias(label) {
            // Mermaid alias can only contain letters, numbers, underscores
            return label.replace(/[^a-zA-Z0-9_]/g, '_');
        }

        /**
         * Sort nodes by type (RN -> HN -> SN)
         */
        function sortNodesByType(nodes) {
            const typeOrder = { 'RN': 0, 'HN': 1, 'SN': 2 };
            return [...nodes].sort((a, b) => {
                const orderA = typeOrder[a.type] ?? 999;
                const orderB = typeOrder[b.type] ?? 999;
                if (orderA !== orderB) return orderA - orderB;
                return a.id - b.id;
            });
        }

        /**
         * Infer message label from event
         * @param {PacketEvent} event - The packet event
         * @param {Array} allEvents - All events in the timeline (for looking up related events)
         * @param {Array} sortedNodes - Sorted array of nodes (for looking up node types)
         */
        function inferMessageLabel(event, allEvents, sortedNodes) {
            // Try to get from metadata first
            if (event.metadata && event.metadata.messageType) {
                return event.metadata.messageType;
            }
            
            // For PacketInTransitEnd, try to find the corresponding PacketSent event
            if (event.eventType === 'PacketInTransitEnd' && event.edgeKey && allEvents) {
                const sendEvent = allEvents.find(e => 
                    e.packetID === event.packetID &&
                    e.eventType === 'PacketSent' &&
                    e.edgeKey &&
                    e.edgeKey.fromID === event.edgeKey.fromID &&
                    e.edgeKey.toID === event.edgeKey.toID
                );
                if (sendEvent) {
                    // Try metadata first
                    if (sendEvent.metadata && sendEvent.metadata.messageType) {
                        return sendEvent.metadata.messageType;
                    }
                    // Check parent packet ID
                    if (sendEvent.parentPacketID && sendEvent.parentPacketID > 0) {
                        return 'Comp';
                    }
                }
            }
            
            // Check if this is a response packet (has parent packet ID)
            if (event.parentPacketID && event.parentPacketID > 0) {
                return 'Comp';
            }
            
            // Infer from node types and direction
            if (event.edgeKey && sortedNodes) {
                const fromNode = sortedNodes.find(n => n.id === event.edgeKey.fromID);
                const toNode = sortedNodes.find(n => n.id === event.edgeKey.toID);
                
                // If from SN/HN to RN, it's likely a response
                if (fromNode && toNode) {
                    const fromType = fromNode.type || '';
                    const toType = toNode.type || '';
                    if ((fromType === 'SN' || fromType === 'HN') && toType === 'RN') {
                        return 'Comp';
                    }
                    // If from RN to SN/HN, it's likely a request
                    if (fromType === 'RN' && (toType === 'SN' || toType === 'HN')) {
                        return 'Req';
                    }
                }
            }
            
            // Infer from event type
            switch (event.eventType) {
                case 'PacketSent':
                    return 'Req';
                case 'PacketGenerated':
                    return 'Comp';
                default:
                    return 'Message';
            }
        }

        /**
         * Find corresponding receive event for a packet
         */
        function findReceiveEvent(events, packetID, targetNodeID) {
            return events.find(e => 
                e.packetID === packetID && 
                e.nodeID === targetNodeID &&
                (e.eventType === 'PacketInTransitEnd' || e.eventType === 'PacketReceived')
            );
        }

        /**
         * Find events for a specific packet in a specific node
         */
        function findPacketEventsInNode(events, packetID, nodeID) {
            return events.filter(e => 
                e.packetID === packetID && 
                e.nodeID === nodeID
            ).sort((a, b) => a.cycle - b.cycle);
        }

        /**
         * Generate Link identifier from EdgeKey
         */
        function getLinkIdentifier(edgeKey, nodeAliasMap) {
            const fromAlias = nodeAliasMap.get(edgeKey.fromID);
            const toAlias = nodeAliasMap.get(edgeKey.toID);
            if (!fromAlias || !toAlias) {
                return null;
            }
            return `Link_${fromAlias}_${toAlias}`;
        }

        /**
         * Generate Link display name from EdgeKey
         */
        function getLinkDisplayName(edgeKey, nodeAliasMap, sortedNodes) {
            const fromAlias = nodeAliasMap.get(edgeKey.fromID);
            const toAlias = nodeAliasMap.get(edgeKey.toID);
            if (!fromAlias || !toAlias) {
                return null;
            }
            // Get original node labels for display
            const fromNode = sortedNodes.find(n => n.id === edgeKey.fromID);
            const toNode = sortedNodes.find(n => n.id === edgeKey.toID);
            const fromLabel = fromNode ? fromNode.label : fromAlias;
            const toLabel = toNode ? toNode.label : toAlias;
            return `Link ${fromLabel}→${toLabel}`;
        }

        /**
         * Convert TransactionTimeline data to Mermaid sequence diagram syntax
         * @param {TransactionTimeline} timeline - Transaction timeline data
         * @returns {string} Mermaid sequence diagram syntax string
         */
        function convertTimelineToMermaid(timeline) {
            const { events, nodes } = timeline;
            
            if (!events || events.length === 0) {
                return 'sequenceDiagram\n    Note over System: No events available';
            }

            // 1. Define node participants (sorted by type: RN -> HN -> SN)
            const sortedNodes = sortNodesByType(nodes);
            const nodeParticipants = sortedNodes.map(node => {
                const alias = sanitizeAlias(node.label);
                return `    participant ${alias} as "${node.label}"`;
            });
            
            // 2. Build node alias map (nodeID -> Mermaid alias)
            const nodeAliasMap = new Map();
            sortedNodes.forEach(node => {
                nodeAliasMap.set(node.id, sanitizeAlias(node.label));
            });

            // 3. Extract all unique EdgeKeys from events to create Link participants
            const linkMap = new Map(); // EdgeKey string -> {identifier, displayName, edgeKey}
            events.forEach(event => {
                if (event.edgeKey) {
                    const keyStr = `${event.edgeKey.fromID}-${event.edgeKey.toID}`;
                    if (!linkMap.has(keyStr)) {
                        const identifier = getLinkIdentifier(event.edgeKey, nodeAliasMap);
                        const displayName = getLinkDisplayName(event.edgeKey, nodeAliasMap, sortedNodes);
                        if (identifier && displayName) {
                            linkMap.set(keyStr, {
                                identifier: identifier,
                                displayName: displayName,
                                edgeKey: event.edgeKey
                            });
                        }
                    }
                }
            });

            // 4. Build ordered participants list with Links inserted between their source and target nodes
            const orderedParticipants = [];
            const nodeIndexMap = new Map(); // nodeID -> index in sortedNodes
            const nodeAliasToIndex = new Map(); // nodeAlias -> index in orderedParticipants (will be built as we go)
            
            // Build node index map for quick lookup
            sortedNodes.forEach((node, index) => {
                nodeIndexMap.set(node.id, index);
            });
            
            // First pass: add all nodes and track their positions
            sortedNodes.forEach((node) => {
                const nodeAlias = sanitizeAlias(node.label);
                orderedParticipants.push({
                    type: 'node',
                    alias: nodeAlias,
                    label: node.label,
                    nodeID: node.id
                });
                nodeAliasToIndex.set(nodeAlias, orderedParticipants.length - 1);
            });
            
            // Second pass: insert Links between their source and target nodes
            const linksToInsert = Array.from(linkMap.values());
            
            // Sort links by target node position (descending), then by source node position
            // This way we insert from right to left, avoiding index shifting issues
            linksToInsert.sort((a, b) => {
                const aTargetIndex = nodeIndexMap.get(a.edgeKey.toID) ?? 999;
                const bTargetIndex = nodeIndexMap.get(b.edgeKey.toID) ?? 999;
                if (aTargetIndex !== bTargetIndex) {
                    return bTargetIndex - aTargetIndex; // Descending order
                }
                const aSourceIndex = nodeIndexMap.get(a.edgeKey.fromID) ?? 999;
                const bSourceIndex = nodeIndexMap.get(b.edgeKey.fromID) ?? 999;
                return bSourceIndex - aSourceIndex; // Descending order
            });
            
            // Insert each link between its source and target nodes
            // Insert from right to left to avoid index shifting
            linksToInsert.forEach(link => {
                const sourceIndex = nodeIndexMap.get(link.edgeKey.fromID);
                const targetIndex = nodeIndexMap.get(link.edgeKey.toID);
                
                if (sourceIndex === undefined || targetIndex === undefined) {
                    return; // Skip if nodes not found
                }
                
                // Find the actual positions in orderedParticipants array
                // Since we're inserting from right to left, we need to find current positions
                let sourcePos = -1;
                let targetPos = -1;
                
                for (let i = 0; i < orderedParticipants.length; i++) {
                    const item = orderedParticipants[i];
                    if (item.type === 'node') {
                        if (item.nodeID === link.edgeKey.fromID && sourcePos === -1) {
                            sourcePos = i;
                        }
                        if (item.nodeID === link.edgeKey.toID && targetPos === -1) {
                            targetPos = i;
                        }
                    }
                    if (sourcePos !== -1 && targetPos !== -1) break;
                }
                
                if (sourcePos === -1 || targetPos === -1) {
                    return; // Skip if nodes not found in array
                }
                
                // Find insertion position: between source and target
                let insertAfterIndex;
                if (sourcePos < targetPos) {
                    // Normal case: source comes before target
                    // Insert after source, but before target
                    insertAfterIndex = sourcePos;
                    // Move forward until we're just before the target node
                    while (insertAfterIndex < targetPos - 1) {
                        const nextItem = orderedParticipants[insertAfterIndex + 1];
                        if (nextItem && nextItem.type === 'node' && nextItem.nodeID === link.edgeKey.toID) {
                            break; // We've reached the target node
                        }
                        insertAfterIndex++;
                    }
                } else {
                    // Reverse case: target comes before source
                    // Insert after target, but before source
                    insertAfterIndex = targetPos;
                    while (insertAfterIndex < sourcePos - 1) {
                        const nextItem = orderedParticipants[insertAfterIndex + 1];
                        if (nextItem && nextItem.type === 'node' && nextItem.nodeID === link.edgeKey.fromID) {
                            break; // We've reached the source node
                        }
                        insertAfterIndex++;
                    }
                }
                
                // Insert the link
                orderedParticipants.splice(insertAfterIndex + 1, 0, {
                    type: 'link',
                    identifier: link.identifier,
                    displayName: link.displayName
                });
            });
            
            // Convert to Mermaid participant strings
            const participantStrings = orderedParticipants.map(item => {
                if (item.type === 'node') {
                    return `    participant ${item.alias} as "${item.label}"`;
                } else {
                    return `    participant ${item.identifier} as "${item.displayName}"`;
                }
            });

            // 5. Combine all participants
            const participants = participantStrings.join('\n');
            
            // 6. Build link identifier map (EdgeKey string -> Link identifier)
            const linkIdentifierMap = new Map();
            linkMap.forEach((link, keyStr) => {
                linkIdentifierMap.set(keyStr, link.identifier);
            });

            // 7. Sort events by cycle
            const sortedEvents = [...events].sort((a, b) => {
                if (a.cycle !== b.cycle) {
                    return a.cycle - b.cycle;
                }
                // If same cycle, use sequence to maintain order
                return (a.sequence || 0) - (b.sequence || 0);
            });
            
            // 8. Build message sequence with activation boxes
            const messages = [];
            const activations = new Map(); // Track active activation boxes: identifier -> {startCycle, type}
            const packetStates = new Map(); // Track packet states: packetID -> {nodeID, state, cycle}
            
            sortedEvents.forEach(event => {
                const nodeAlias = nodeAliasMap.get(event.nodeID);
                if (!nodeAlias && event.eventType !== 'PacketSent' && event.eventType !== 'PacketInTransitEnd') {
                    return;
                }
                
                const cycle = event.cycle;
                
                switch (event.eventType) {
                    case 'PacketSent':
                        if (event.edgeKey) {
                            const fromAlias = nodeAliasMap.get(event.edgeKey.fromID);
                            const toAlias = nodeAliasMap.get(event.edgeKey.toID);
                            if (!fromAlias || !toAlias) break;
                            
                            // Get Link identifier
                            const keyStr = `${event.edgeKey.fromID}-${event.edgeKey.toID}`;
                            const linkIdentifier = linkIdentifierMap.get(keyStr);
                            if (!linkIdentifier) break;
                            
                            const messageLabel = inferMessageLabel(event, events, sortedNodes);
                            const sendCycle = cycle;
                            
                            // Node -> Link: Real-time (send time = Link receive time)
                            messages.push(`    ${fromAlias}->>${linkIdentifier}: ${messageLabel} (cycle ${sendCycle})`);
                            
                            // Activate Link to represent packet in transit
                            const linkActivationKey = `link_${event.packetID}_${keyStr}`;
                            if (!activations.has(linkActivationKey)) {
                                messages.push(`    activate ${linkIdentifier}`);
                                activations.set(linkActivationKey, {
                                    identifier: linkIdentifier,
                                    startCycle: sendCycle,
                                    type: 'link_transmission',
                                    packetID: event.packetID
                                });
                            }
                            
                            // Track packet state
                            packetStates.set(event.packetID, {
                                nodeID: event.edgeKey.toID,
                                state: 'in_link',
                                cycle: sendCycle
                            });
                        }
                        break;
                        
                    case 'PacketInTransitEnd':
                        // Link -> Node: Shows delay (packet transmission time in Link)
                        if (event.edgeKey) {
                            const toAlias = nodeAliasMap.get(event.nodeID);
                            if (!toAlias) break;
                            
                            // Get Link identifier
                            const keyStr = `${event.edgeKey.fromID}-${event.edgeKey.toID}`;
                            const linkIdentifier = linkIdentifierMap.get(keyStr);
                            if (!linkIdentifier) break;
                            
                            const messageLabel = inferMessageLabel(event, events, sortedNodes);
                            const receiveCycle = cycle;
                            
                            // Find send event to calculate delay
                            const sendEvent = events.find(e => 
                                e.packetID === event.packetID &&
                                e.eventType === 'PacketSent' &&
                                e.edgeKey &&
                                e.edgeKey.fromID === event.edgeKey.fromID &&
                                e.edgeKey.toID === event.edgeKey.toID
                            );
                            const sendCycle = sendEvent ? sendEvent.cycle : receiveCycle;
                            const delay = receiveCycle - sendCycle;
                            
                            // Link -> Node: Shows transmission delay
                            if (delay > 0) {
                                messages.push(`    ${linkIdentifier}->>${toAlias}: ${messageLabel} (delay: ${delay} cycles, cycle ${receiveCycle})`);
                            } else {
                                messages.push(`    ${linkIdentifier}->>${toAlias}: ${messageLabel} (cycle ${receiveCycle})`);
                            }
                            
                            // Deactivate Link (packet left the link)
                            const linkActivationKey = `link_${event.packetID}_${keyStr}`;
                            if (activations.has(linkActivationKey)) {
                                messages.push(`    deactivate ${linkIdentifier}`);
                                activations.delete(linkActivationKey);
                            }
                            
                            // Update packet state
                            packetStates.set(event.packetID, {
                                nodeID: event.nodeID,
                                state: 'received',
                                cycle: cycle
                            });
                        }
                        break;
                        
                    case 'PacketReceived':
                        // Node received the message
                        packetStates.set(event.packetID, {
                            nodeID: event.nodeID,
                            state: 'received',
                            cycle: cycle
                        });
                        break;
                        
                    case 'PacketEnqueued':
                        // Start queue waiting activation box
                        const queueKey = `queue_${event.packetID}_${event.nodeID}`;
                        if (!activations.has(queueKey)) {
                            const nodeAlias = nodeAliasMap.get(event.nodeID);
                            messages.push(`    activate ${nodeAlias}`);
                            activations.set(queueKey, {
                                nodeID: event.nodeID,
                                startCycle: cycle,
                                type: 'queue',
                                packetID: event.packetID
                            });
                        }
                        packetStates.set(event.packetID, {
                            nodeID: event.nodeID,
                            state: 'queued',
                            cycle: cycle
                        });
                        break;
                        
                    case 'PacketDequeued':
                        // End queue waiting activation box
                        const dequeueKey = `queue_${event.packetID}_${event.nodeID}`;
                        if (activations.has(dequeueKey)) {
                            const nodeAlias = nodeAliasMap.get(event.nodeID);
                            messages.push(`    deactivate ${nodeAlias}`);
                            activations.delete(dequeueKey);
                        }
                        packetStates.set(event.packetID, {
                            nodeID: event.nodeID,
                            state: 'dequeued',
                            cycle: cycle
                        });
                        break;
                        
                    case 'PacketProcessingStart':
                        // Start processing activation box
                        const processKey = `process_${event.packetID}_${event.nodeID}`;
                        if (!activations.has(processKey)) {
                            const nodeAlias = nodeAliasMap.get(event.nodeID);
                            messages.push(`    activate ${nodeAlias}`);
                            activations.set(processKey, {
                                nodeID: event.nodeID,
                                startCycle: cycle,
                                type: 'processing',
                                packetID: event.packetID
                            });
                        }
                        messages.push(`    Note over ${nodeAlias}: Processing (cycle ${cycle})`);
                        break;
                        
                    case 'PacketProcessingEnd':
                        // End processing activation box
                        const processEndKey = `process_${event.packetID}_${event.nodeID}`;
                        if (activations.has(processEndKey)) {
                            const nodeAlias = nodeAliasMap.get(event.nodeID);
                            messages.push(`    deactivate ${nodeAlias}`);
                            activations.delete(processEndKey);
                        }
                        break;
                        
                    case 'PacketGenerated':
                        // Node generated new message (self-loop)
                        const messageLabel = inferMessageLabel(event, events, sortedNodes);
                        messages.push(`    ${nodeAlias}->>${nodeAlias}: ${messageLabel} (cycle ${cycle})`);
                        break;
                }
            });
            
            // Close any remaining activation boxes
            activations.forEach((activation, key) => {
                messages.push(`    deactivate ${activation.identifier}`);
            });
            
            // 9. Combine into complete Mermaid syntax
            const mermaidCode = `sequenceDiagram
${participants}

${messages.join('\n')}`;
            
            return mermaidCode;
        }

        /**
         * Render sequence diagram using Mermaid.js
         * @param {string} containerId - Container element ID
         * @param {TransactionTimeline} timeline - Transaction timeline data
         */
        async function renderMermaidSequenceDiagram(containerId, timeline) {
            const container = document.getElementById(containerId);
            if (!container) {
                console.error(`Container ${containerId} not found`);
                return;
            }
            
            // Show loading state
            container.innerHTML = '<div class="sequence-diagram-loading">Generating sequence diagram...</div>';
            
            // Check if Mermaid is loaded
            if (typeof mermaid === 'undefined') {
                container.innerHTML = '<div class="sequence-diagram-error">Mermaid.js library not loaded</div>';
                return;
            }
            
            let mermaidCode = '';
            try {
                // Convert data to Mermaid syntax
                mermaidCode = convertTimelineToMermaid(timeline);
                
                // Initialize Mermaid (safe to call multiple times)
                mermaid.initialize({
                    startOnLoad: false,
                    theme: 'default',
                    sequence: {
                        diagramMarginX: 50,
                        diagramMarginY: 10,
                        actorMargin: 50,
                        width: 150,
                        height: 65,
                        boxMargin: 10,
                        boxTextMargin: 5,
                        noteMargin: 10,
                        messageMargin: 35,
                        mirrorActors: true,
                        bottomMarginAdj: 1,
                        useMaxWidth: true,
                        rightAngles: false,
                        showSequenceNumbers: false
                    }
                });
                
                // Create unique ID for this diagram
                const diagramId = `mermaid-diagram-${timeline.transactionID || Date.now()}`;
                
                // Render the diagram
                const { svg } = await mermaid.render(diagramId, mermaidCode);
                
                // Display the rendered SVG
                container.innerHTML = svg;
                
            } catch (error) {
                console.error('Mermaid rendering error:', error);
                container.innerHTML = `<div class="sequence-diagram-error">Failed to render sequence diagram: ${error.message}<br><br>Mermaid Code:<br><pre style="font-size: 10px; overflow: auto;">${mermaidCode || 'N/A'}</pre></div>`;
            }
        }

        /**
         * Load and display transaction timeline
         */
        async function loadAndRenderTimeline(txnID) {
            const errorDiv = document.getElementById('timelineError');
            const container = document.getElementById('sequenceDiagramContainer');
            
            if (!txnID || txnID <= 0) {
                errorDiv.textContent = 'Please enter a valid transaction ID';
                errorDiv.classList.add('show');
                return;
            }
            
            errorDiv.classList.remove('show');
            errorDiv.textContent = '';
            
            // Show modal
            const modal = document.getElementById('sequenceDiagramModal');
            const title = document.getElementById('sequenceDiagramTitle');
            title.textContent = `Transaction Timeline - ID: ${txnID}`;
            modal.classList.add('show');
            
            // Show loading state
            container.innerHTML = '<div class="sequence-diagram-loading">Loading transaction timeline...</div>';
            
            try {
                const response = await fetch(`/api/transaction/${txnID}/timeline`);
                if (!response.ok) {
                    if (response.status === 404) {
                        throw new Error(`Transaction ${txnID} not found`);
                    }
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const timeline = await response.json();
                
                if (!timeline || !timeline.events || timeline.events.length === 0) {
                    container.innerHTML = '<div class="sequence-diagram-error">No events found for this transaction</div>';
                    return;
                }
                
                // Render the sequence diagram
                await renderMermaidSequenceDiagram('sequenceDiagramContainer', timeline);
                
            } catch (error) {
                console.error('Failed to load timeline:', error);
                container.innerHTML = `<div class="sequence-diagram-error">Failed to load transaction timeline: ${error.message}</div>`;
            }
        }

        // Event listeners for sequence diagram
        document.getElementById('btnLoadTimeline').addEventListener('click', async () => {
            const txnID = parseInt(document.getElementById('transactionID').value);
            await loadAndRenderTimeline(txnID);
        });

        document.getElementById('transactionID').addEventListener('keypress', async (e) => {
            if (e.key === 'Enter') {
                const txnID = parseInt(document.getElementById('transactionID').value);
                await loadAndRenderTimeline(txnID);
            }
        });

        // Close sequence diagram modal
        document.getElementById('sequenceDiagramClose').addEventListener('click', () => {
            document.getElementById('sequenceDiagramModal').classList.remove('show');
        });

        document.getElementById('sequenceDiagramModal').addEventListener('click', function(e) {
            if (e.target === this) {
                this.classList.remove('show');
            }
        });
    </script>
</body>
</html>

